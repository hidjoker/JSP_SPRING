<<1과목 데이터 베이스>>

	- 001. 정보시스템

		: 조직체에 필요한 Data를 수집, 저장해 두었다가 필요시에 
		처리해서 의사 결정에 유용한 정보를 생성하고 분배하는 수단이다

		사용하는 목적에 따라 경영 정보 시스템, 군사 정보 시스템
		인사 행정 정보 시스템, 의사 결정 지원 시스템 등으로 사용된다.

		정보와 자료
	
		- 자료(Data) : 현실 세계에서 관찰이나 측정을 통해 수집한 단순한
		   	       사실이나 결과값으로, 가공되지 않은 상태
		- 정보(Information) : 의사 결정에 도움을 줄 수 있는 유용한 형태로,
			              자료를 가공(처리)해서 얻은 결과물

		자료 ㅡ> 자료처리 시스템(가공,처리) ㅡ> 정보
		
		- 자료 처리 시스템 : 정보 시스템이 사용할 자료를 처리하는 정보 시스템의
				    서브 시스템으로, 처리 형태에 따라 일괄 처리 시스템,
				   온라인 실시간 처리 시스템, 분산 처리 시스템으로 분류

		데이터웨어 하우스(DataWare House) :
				조직이나 기업체의 중심이 되는 주요 업무 시스템에서 추출되어
				새로이 생성된 데이터 베이스로서 의사결정 지원 시스템을 지원하는
				주체적, 통합적, 시간적 데이터의 집합체


	- 002. 데이터베이스의 정의
	
		(1)통합된 데이터(Integrated Data) :
			자료의 중복을 배제한 데이터의 모임

		(2)저장된 데이터(Strored Data) :
			컴퓨터가 실시간으로 접근할 수 있는 저장 매체에 저장된 자료

		(3)운영 데이터(Operational Data) :
			조직의 고유한 업무를 수행하는 데 있어서 존재 가치가 확실하고 없어서는 안될
			반드시 필요한 자료
		
		(4)공용 데이터(Shared Data) :
			여러 응용 시스템들이 공동으로 소유하고 유지하는 자료

		

	- 003. 데이터베이스의 특성

		(1) 실시간 접근성(Real Time Accessibility) :
			수시적이고 비정형적인 질의(조회)에 대하여 실시간 처리(Real-Time-Processing)에
			의한 응답이 가능함
		(2) 계속적인 변화(Continuous Evolution) :
			새로운 데이터의 삽입(Insertion), 삭제(Deletion), 갱신(Update)으로
			항상 최신의 데이터를 유지함
		(3) 동시 공유(동시 공용)(Concurrent Sharing) :
			여러 사용자가 동시에 자기가 원하는 데이터를 이용할 수 있음
		(4) 내용에 의한 참조(Content Reference) :
			데이터베이스에 있는 데이터를 참조할 때 데이터 주소나 위치에 의해서가 아니라
			사용자가 요구하는 데이터 내용으로 데이터를 찾음

	- 004. 기존의 파일 처리 방식에서의 문제점
		
		(1)종속성으로 인한 문제점
			: 종속성이란 응용 프로그램과 데이터 파일이 상호 의존적인 관계를 말한다

			데이터 파일이 보조기억장치에 저장되는 방법이나 저장된 데이터의 접근 방법을 변경할
			때는 응용프로그램도 같이 변경해야 한다

		(2)중복성으로 인한 문제점
			일관성 : 중복된 데이터 간에 내용이 일치하지 않는 상황이 발생하여 일관성이 없어짐
			보안성 : 중복되어 있는 모든 데이터에 동등의 보안 수준을 유지하기가 어려움
			경제성 : 저장 공간의 낭비와 동일한 데이터의 반복 작업으로 인한 비용의 증가
			무결성 : 제어의 분산으로 인해 데이터의 정확성을 유지할 수 없음


	- 005. DBMS의 정의 및 필수 기능
		
		: DBMS란 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고,
		데이터베이스를 관리해 주는 소프트웨어로 다음과 같은 3가지의 필수 기능이 있다

		(1)정의(조직)(Definition) 기능 : 데이터의 형(Type)과 구조, 데이터가 DB에 저장될 때의
						제약 조건 등을 명시하는 기능
		(2)조작(Manipulation) 기능 : 데이터의 검색, 갱신, 삽입 삭제 등을 체계적으로 처리하기
				   	     위해 데이터 접근 수단 등을 정하는 기능
		(3)제어(Control) 기능
			- 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의
			  무결성이 유지되도록 제어해야 한다
			- 정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안(Security)을 유지하고 
			  권한(Authority)을 검사할 수 있어야 한다.
			- 여러 사용자가 데이터베이스를 동시에 접근하여 데이터를 처리할 때 처리 결과가
			  항상 정확성을 유지하도록 병행 제어(Concurrency Control)를 할 수 있어야 한다.


	- 006. DBMS의 장, 단점
	
		(1) 장점
		- 데이터의 중복을 피할 수 있음
		- 저장된 자료를 공동으로 이용할 수 있음
		- 데이터의 일관성, 무결성을 유지할 수 있음
		- 보안을 유지할 수 있음
		- 데이터를 표준화할 수 있음
		- 데이터를 통합하여 관리할 수 있음
		- 항상 최신의 데이터를 유지함
		- 데이터의 실시간 처리가 가능함
		- 데이터의 논리적, 물리적 독립성이 보장됨

		(2) 단점
		- 데이터베이스 전문가 부족
		- 전산화 비용이 증가함
		- 대용량 디스크로의 집중적인 Access로 과부하(Overhead)가 발생함
		- 파일의 예비(Backup)와 회복(Recovery)이 어려움
		- 시스템이 복잡함
		- 파일 시스템에 비해 자료 처리 방법이 복잡함

		논리적 독립성과 물리적 독립성
		(1) 논리적 독립성
			: 응용 프로그램과 데이터베이스를 독립시킴으로써, 데이터의 논리적 구조를 변경
			  시키더라도 응용 프로그램은 변경되지 않음
		
		(2) 물리적 독립성
			: 응용 프로그램과 보조기억장치 같은 물리적 장치를 독립시킴으로써, 데이터베이스
			  시스템의 성능 향상을 위해 새로운 디스크를 도입하더라도 응용 프로그램에는 
			  영향을 주지 않고 데이터의 물리적 구조만을 변경함
		
		백업(Backup)
		: 장비 고장 등의 비상사태에도 데이터베이스가 보존되도록 복사해 놓는 작업
		
	- 007. 스키마(Schema)의 정의
		- 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specification)를 기술(Description)
		  한다.
		- 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship)및
		  데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다.
		- 스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나누어진다.
		- 스키마(Schema)는 데이터 사전에 저장되며, 다른 이름으로 메타데이터(Meta-data)라고도 한다


	- 008. 스키마의 3계층
		(1) 외부 스키마(Extermal Schema) = 서브 스키마 = 사용자 뷰(View)
			- 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의
			  논리적 구조를 정의한다
			- 전체 데이터베이스의 한 논리적인 부분으로 볼 수 있으므로 서브 스키마(Subschema)
			  라고도 한다.
			- 하나의 데이터베이스 시스템에는 여러 개의 외부 스키마가 존재할 수 있으며,
			  하나의 외부 스키마를 여러 개의 응용 프로그램이나 사용자가 공용할 수 있다.
			- 같은 데이터베이스에 대해서도 서로 다른 관점을 정의할 수 있도록 허용한다.
			- 일반 사용자는 질의어(SQL)를 사용하며 DB를 사용한다.

		(2) 개념 스키마(Conceptual Schema) = 전체적인 뷰(View)
			- 데이터베이스의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이
			  필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재한다
			- 개념 스키마는 개체 간의 관계와 제약 조건을 나타내고 데이터베이스의
			  접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의한다
			- 데이터베이스 파일에 저장되는 데이터의 형태를 나타낸 것으로 단순히 스키마
			  (Schema)라고 하면 개념 스키마를 의미한다
			- 기관이나 조직체의 관점에서 데이터베이스를 정의한 것이다
			- 데이터베이스 관리자에 의해서 구성된다.

		(3) 내부 스키마(Internal Schema)
			- 물리적 저장장치의 입장에서 본 데이터베이스 구조로, 물리적인 저장장치와 
			  밀접한 계층이다.
			- 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고, 저장 데이터
			  항목의 표현 방법, 내부레코드의 물리적 순서등을 나타낸다.
			- 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마이다.

	- 009. 데이터베이스 언어(Database Language)
		(1) 데이터 정의 언어(DDL; Data Definition Language)
			- DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로
			  사용하는 언어이다.
			- 번역한 결과가 데이터 사전(Data-Dictionary)이라는 특별한 파일에 여러 개의
			  테이블로 저장된다
			- 데이터 정의 언어의 기능
			  : 외부 스키마 명세 정의, 데이터베이스 정의 및 수정,
			    스키마에 사용되는 제약 조건에 대한 명세 정의, 데이터의 물리적인 순서 규정
		(2) 데이터 조작 언어(DML; Data Manipulation Language) = 서브 언어
			- 사용자로 하여금 데이터를 처리할 수 있게 하는 도구로서 사용자(응용프로그램)와
			  DBMS 간의 인터페이스를 제공한다
			- 응용 프로그램을 통하여 사용자가 DB의 데이터를 실질적으로 조작할 수 있도록
			  하기 위해 C, COBOL 등의 호스트 언어에 DB 기능을 추가시켜 만든 언어이다.
			- 대표적인 데이터 조작어(DML)에는 질의어가 있으며, 질의어는 터미널에서 주로
			  이용하는 비절차적(Non procedural) 데이터 언어이다.
	
	- 010. 데이터베이스 사용자
		(1) DBA(DataBase Administrator)
			: 데이터베이스 시스템의 모든 관리와 운영에 대한 책임을 지고 있는 사람이나
			  그룹을 의미한다
			- 데이터베이스 구성 요소 결정
			- 개념 스키마 및 내부 스키마 정의
			- 데이터베이스의 저장 구조 및 접근 방법 정의
			- 보안 및 데이터베이스의 접근 권한 부여 정책 수립
			- 장애에 대비한 예비(Back Up)조치와 회복(Recovery)에 대한 전략 수립
			- 무결성을 위한 제약 조건의 지정
			- 데이터 사전의 구성과 유지 관리
			- DBMS의 선택, 보완, 평가에 대한 책임
			- 사용자의 요구와 불평의 청취 및 해결
			- 변화 요구에 대한 적응과 성능 향상에 대한 감시
			- 시스템 감시 및 성능 분석
			- 데이터 사용 추세, 이용 형태 및 각종 통계 등을 종합, 분석
		(2) 응용 프로그래머
			- 응용 프로그래머는 일반 호스트 언어로 프로그램을 작성할 때 데이터 조작어를
			  삽입해서 일반 사용자가 응용 프로그램을 사용할 수 있게, 인터페이스를 제공할
			  목적으로 데이터베이스를 접근하는 사람들이다.
			- 응용 프로그래머는 C, COBOL, PASCAL 등의 호스트 언어와 DBMS가 지원하는 데이터
			  조작어에 능숙한 컴퓨터 전문가이다.
		(3) 일반 사용자
			- 일반 사용자는 보통 터미널을 이용하여 데이터베이스에 있는 자원을 활용할 목적
			  으로 질의어나 응용 프로그램을 사용하여 데이터베이스에 접근하는 사람들이다.
		

	- 011. 데이터 모델의 정의
		- 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한
		  개념적 모형이다
		- 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적
		  도구들의 모임이다.
		- 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터
		  의 구조를 논리적으로 표현하기 위해 사용되는 도구이다.

	- 012. 데이터 모델에 표시할 사항
		- 구조(Structure) : 논리적으로 표현한 개체들 간의 관계를 표시함
		- 연산(Operation) : 데이터베이스에 저장된 실제 데이터를 처리하는 방법을 표시함
				    데이터베이스를 조작하는 기본 도구임
		- 제약조건(Constraint) : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약
					 조건을 표시함

	- 013. 데이터 모델의 구성 요소
		(1) 개체(Entity)
			- 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은
			  현실 세계의 대상체이다.
			- 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 구성된다.
			- 파일 시스템의 레코드에 대응하는 것으로, 어떤 정보를 제공하는 역할을 수행한다
			- 독립적으로 존재하거나 그 자체로서도 구별이 가능하다.
		(2) 속성(Attribute)
			- 데이터의 가장 작은 논리적 단위로서 파일 구조의 데이터 항목 또는 데이터
			  필드에 해당된다.
			- 개체를 구성하는 항목이다.
		[교수 개체의 구성 요소]
			1. 속성 : 개체가 가지고 있는 특성, 교수번호, 성명, 전공, 소속
			2. 개체 타입 : 속성으로만 기술된 개체의 정의
			3. 개체 인스턴스 : 개체를 구성하고 있는 각 속성들이 값을 가져 하나의 개체를
					   나타내는 것으로 개체 어커런스(Occurence)라고도 함
			4. 개체 세트 : 개체 인스턴스의 집합
		(3) 관계(Relationship)
			- 개체 간의 관계 또는 속성 간의 관계

	- 014. 개체-관계(Entity-Relationship) 모델
		- 개념적 데이터 모델의 가장 대표적인 것으로, 1976년 Peter Chen에 의해 제안되었다
		- 개체 타입(Entity Type)과 이들 간의 관계 타입(Relationship Type)을 이용해 현실
		  세계를 개념적으로 표현한다.
		- 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 묘사한다.
		- 특정 DBMS를 고려하는 것은 아니다
		- E-R 다이어그램을 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있다.

	- 015. E-R 다이어그램
		- E-R 모델의 기본적인 아이디어를 시각적으로 표현하기 위한 도구이다.
		- 개체 간의 관계는 물론 시스템 내의 역할을 하는 모든 개체들, 즉 조직, 부서, 사용자,
		  프로그램, 데이터를 모두 표시한다
		
		사각형 - 개체(Entity) 타입
		마름모 - 관계(Relationship) 타입
		타원 - 속성(Attribute) 타입
		밑줄 타원 - 기본키 속성
		복수 타원 - 복합 속성
		관계 - 1:1, 1:N, N:M등의 개체 관계에 대해 선 위에 대응수 기술
		선, 링크 - 개체 타입과 속성 연결

	- 016. 계층형 데이터 모델
		- 데이터의 논리적 구조도가 트리 형태이며, 개체가 트리를 구성하는 노드 역할을 한다
		- 개체 집합에 대한 속성 관계를 표시하기 위해 개체를 노드로 표현하고 개체 집합들
		  사이의 관계를 링크로 연결한다
		- 개체 간의 관계를 부모와 자식 간의 관계로 표현한다.
		- 개체 타입 간에는 상위와 하위 관계가 존재하며, 일 대다(1:N) 대응 관계만 존재한다.
		- 레코드 삭제 시 연쇄 삭제(Triggered Delete)가 된다
		- 개체 타입들 간에는 사이클(Cycle)이 허용되지 않는다.
		- 계층형 모델에서는 개체(Entity)를 세그먼트(Segment)라 부른다
		- 대표적인 DBMS : IMS 등

	- 017. 망(그래프, 네트워크)형 데이터 모델
		- CODASYL이 제안한 것으로, CODASYL DBTG모델 이라고도 한다.
		- 그래프를 이용해서 데이터 논리 구조를 표현한 데이터 모델이다
		- 상위와 하위 레코드 사이에서 다 대 다(N:M) 대응 관계를 만족하는 구조이다.
		- 상위의 레코드를 Owner, 하위의 레코드를 Member라 하여 Owner-Member 관계라고도 한다.
		- 레코드 타입 간의 관계는 1:1, 1:N, N:M이 될 수 있다.
		- 대표적인 DBMS : DBTG, EDBS, TOTAL 등


	- 018. 데이터베이스 설계
		(1) 개념적 설계(정보 모델링, 개념화)
			- 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고,
			  다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로
			  표현하는 과정이다.
			- 개념 스키마 모델링과 트랜잭션 모델링을 병행하여 수행한다.
			- 요구 분석 단계에서 나온 결과(요구 조건 명세)를 DBMS에 독립적인 E-R다이어그램
			  (개체 관계도)으로 작성한다.
			- DBMS에 독립적인 개념 스키마를 설계한다.
		(2) 논리적 설계(데이터 모델링)
			- 현실 세계에서 발생하는 자료를 컴퓨터가 처리할 수 있는 물리적 저장장치에 
			  저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로
			  변환시키는 과정이다
			- 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 
			  관계로 표현되는 논리적 구조의 데이터로 모델화 한다.
			- 개념적 설계가 개념 스키마를 설계하는 단계라면 논리적 설계에서는 개념 스키마
			  를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계이다.
			- 트랜잭션의 인터페이스를 설계한다.
			- 관계형 데이터베이스라면 테이블을 설계하는 단계이다.
		(3) 물리적 설계(데이터 구조화)
			- 논리적 설계 단계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치
			  에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다.
			- 물리적 설계 단계에서는 다양한 데이터베이스 응용에 대한 처리 성능을 얻기 위해
			  데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다
			- 저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 데이터가 컴퓨터에
			  저장되는 방법을 묘사한다.
			- 물리적 설계 단계에 꼭 포함되어야 할 것은 저장 레코드의 양식 설계, 레코드 집중
			  (Record Clustering)의 분석 및 설계, 접근 경로 설계 등이 있다.
			- 물리적 데이터베이스 구조의 기본적인 데이터 단위는 저장 레코드(Stored Record)
			  이다.
			- 물리적 데이터베이스 구조는 여러 가지 타입의 저장 레코드 집합이라는 면에서
			  단순한 파일과 다르다.
			- 물리적 데이터베이스 구조는 데이터베이스 시스템의 성능에 중대한 영향을 미친다.
			
			<> 물리적 설계 옵션 선택시 고려 사항
				(1) 반응시간(Reponse Time) : 트랜잭션 수행을 요구한 시점부터 처리 결과
							   를 얻을 때까지의 경과(응답) 시간
				(2) 공간 활용도(Space Utilization) : 데이터베이스 파일과 액세스 경로
								  구조에 의해 사용되는 저장 공간의 양
				(3) 트랜잭션 처리량(Transaction Throughput) : 단위 시간 동안 데이터
									베이스 시스템에 의해 처리될 수
									있는 트랜잭션의 평균 개수
				
	- 019. 데이터베이스 설계 순서
		(1) 요구 분석 : 요구 조건 명세서 작성
		(2) 개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R모델
		(3) 논리적 설계 : 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스 설계
		(4) 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
		(5) 구현 : 특정 DBMS의 DDL 데이터베이스 생성, 트랜잭션 생성

	- 020. 파일 관계 데이터베이스의 Relation 구조 시스템
		: 릴레이션은 데이터들을 표(Table)의 형태로 표현한 것으로, 구조를 나타내는 릴레이션
		  스키마와 실제 값들인 릴레이션 인스턴스로 구성된다.
	
		(1) 튜플(Tuple)
			- 릴레이션을 구성하는 각각의 행
			- 속성의 모임으로 구성된다
			- 파일 구조에서 레코드와 같은 의미이다
			- 튜플의 수 = 카디널리티(Cardinality) = 기수 = 대응수
		(2) 속성(Attribute, 애트리뷰트)
			- 데이터베이스를 구성하는 가장 작은 논리적 단위
			- 파일 구조상의 데이터 항목 또는 데이터 필드(열)에 해당된다.
			- 개체의 특성을 기술한다
			- 속성의 수 = 디그리(Degree) = 차수
		(3) 도메인(Domain)
			- 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(atomic)값들의 집합
			- 실제 애트리뷰트 값이 나타날 떄 그 값의 합법 여부를 시스템이 검사하는
			  데에도 이용된다
		(4) 릴레이션 스키마
			- 한 릴레이션의 논리적 구조를 기술한 것이다
			- 릴레이션 스키마는 정적인 성질을 가지며 릴레이션 인스턴스 동적인 성질을

			  가진다
		(5) 릴레이션 인스턴스
			- 데이터 개체를 구성하고 있는 속성들에 데이터 타입이 정의되어 구체적인
			  데이터 값을 갖고 있는 것을 말한다		

	- 021. 릴레이션의 특징
		- 한 릴레이션에 포함된 튜플들은 모두 상이하다
		- 한 릴레이션에 포함된 튜플 사이에는 순서가 없다
		- 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다
		- 릴레이션의 스키마를 구성하는 속성들 간의 순서는 중요하지 않다
		- 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은
		  동일한 값이 있을 수 있다
		- 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로
		  설정한다
		- 속성은 더 이상 쪼갤 수 없는 원자값만을 저장한다

	- 022. 키(Key)의 개념 및 종류
		: 키(Key)는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때
		  다른 튜플들과 구별할 수 있는 유일한 기준이 되는 애트리뷰트(속성)이다

		(1) 후보키(Candidate Key)
			- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해
			  사용하는 속성들의 부분집합, 즉 키본기로 사용할 수 있는 속성들을 말함
			- 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 함
		(2) 기본키(Primary Key)
			- 후보키 중에서 선택한 주키(Main Key)
			- 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
			- Null 값을 가질 수 없음
			- 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없음
		(3) 대체키(Altermate Key)
			- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말하며,
			  보조키라고도 함
		(4) 슈퍼키(Super Key)
			- 슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서
			  릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값
		  	  은 나타나지 않음
			- 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 
			  만족시키지 못함
		(5) 외래키(Foreign Key)
			- 관계(Relationship)를 맺고 있는 릴레이션 R1,R2에서 릴레이션 R1이 참조하고
			  있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성
			- 관계형 데이터 모델에서 외래키는 참조되는 릴레이션의 기본키와 대응되어
			  릴레이션 간에 참조 관계를 표현하는데 중요한 도구로 사용됨
			- 외래키로 지정하면 참조 테이블의 기본키에 없는 값은 입력할 수 없음

		<> 널 값/최소성과 유일성
		- 널 값(NULL Value) : 데이터베이스에서 아직 알려지지 않았거나 모르는 값으로서
				     "해당 없음"등의 이유로 정보 부재를 나타내기 위해 사용하는
				     이론적으로 아무것도 없는 특수한 데이터
		- 최소성과 유일성 : "학번"+"주민번호"를 사용하여 슈퍼키를 만들면 다른 튜플들과
				    구분할 수 있는 유일성은 만족하지만, '학번'이나 '주민번호'하나만
				    가지고도 다른 튜플들을 구분할 수 있으므로 최소성은 만족시키지
				    못함

	- 023. 무결성(Intergrity)
		(1) 개체 무결성 : 릴레이션에서 기본키를 구성하는 속성은 널(NULL) 값이나 중복값을
				  가질 수 없음
		(2) 참조 무결성 : 외래키 값은 NULL 이거나 참조 릴레이션의 기본키 값과 동일해야 함,
				  즉 릴레이션은 참조할 수 없는 외래키값을 가질 수 없음
		(3) 도메인 무결성 : 특정 속성의 값이, 그 속성이 정의된 도메인에 속한 값이어야 한다는
				    규정

	- 024. 관계대수
		- 관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는
		  절차적인 언어이다
		- 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하는 언어로 피연산자가 릴레이션
		  이고, 결과도 릴레이션이다.
		- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다
		(1) 순수 관계 연산자 : Select, Project, Join, Division
		(2) 일반 집합 연산자 : UNION(합집합), INTERSECTION(교집합), DIFFERENCE(차집합),
				       Cartesian, Product(교차곱)

	- 025. 순수 관계 연산자
		: 관계 데이터베이스에 적용할 수 있도록 특별히 개발한 관계 연산자
		(1) Select
			- 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 
			  구하여 새로운 릴레이션을 만듦
			- 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 함
			- 연산자의 기호는 그리스 문자 시그마를 사용함
		(2) Project
			- 주어진 릴레이션에서 속성 List에 제시된 Attribute만을 추출하는 연산
			- 릴레이션의 열(세로)에 해당하는 Attribute를 추출하는 것이므로 수학 연산자
			  라고도 함
			- 연산자의 기호는 그리스 문자 파이를 사용함
		(3) Join
			- 공통 속성을 중심으로 2개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을
			  만드는 연산
			- 조인 조건이 '='일 때 동일한 속성이 두 번 나타나게 되는데, 이 중 중복된
			  속성을 제거하여 같은 속성을 한 번만 표기하는 방법을 자연(NATURAL)조인
			  이라고 함
		(4) Division 
			- Y를 포함하는 X 2개의 릴레이션에서 R(X)와 S(Y)가 있을 때, R의 속성이 S의
			  속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산

	- 026. 일반 집합 연산자
		- 수학적 집합 이론에서 사용하는 연산자이다
		- 일반 집합 연산자 중 합집합, 교집합, 차집합은 합병조건이 가능해야 한다
		- 합병 가능한 두 릴레이션 R과 S가 있을 떄 각 연산의 특징을 요약하면 다음과 같다
		(1) 합집합(UNION)
			- 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서
			  중복되는 튜플은 제거됨
			- 합집합의 카디널리티는 두 릴레이션 커디널리티의 합보다 크지 않음
		(2) 교집합(INTERSECTION)
			- 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산
			- 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티
			  보다 크지 않음
		(3) 차집합(DIFFERENCE)
			- 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산
			- 차집합의 카디널리티는 릴레이션 R의 카디널리티보다 크지 않음
		(4) 교차곱(CARTESIAN PRODUCT)
			- 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산
			- 교차곱의 카디널리티는 두 릴레이션의 카디널리티를 곱한 것과 같음

	- 027. 관계해석
		- 코드(E.F codd)가 수학의 Predicate Calculus(술어해석)에 기반을 두고 관계 데이터베이스를 위해
		  제안했다
		- 관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지닌다.
		- 원하는 정보를 정의할 때는 계산 수식을 사용한다.
		- 튜플 관계해석과 도메인 관계해석이 있다.
		- 기본적으로 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력 면에서 동등하다.
		- 질의어로 표현한다.

	- 028. 정규화(Normalization)
		(1) 정규화의 개요
			- 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의
			  세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다.
			- 정규형에는 제1정규형, 제2정규형, 제3정규형, BCNF형, 제4정규형, 제5정규형이 있으며,
			  차수가 높아질수록 만족시켜야 할 제약 조건이 늘어난다.
			- 정규화는 데이터베이스의 개념적 설계 단계와 논리적 설계 단계에서 수행한다.
			- 정규화는 논리적 처리 및 품질에 큰 영향을 미친다.

		(2) 정규화의 목적
			- 데이터 구조의 안정성을 최대화한다
			- 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만든다.
			- 효과적인 검색 알고리즘을 생성할 수 있다.
			- 중복을 배제하여 삽입, 삭제, 갱신, 이상의 발생을 방지한다

		(3) 정규화의 원칙
			- 정보의 무손실 표현, 즉 하나의 스키마를 다른 스키마로 변환할 때 정보의 손실이 있어서는
			  안된다.
			- 분리의 원칙, 즉 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.
			- 데이터의 중복성이 감소되어야 한다.
 
	- 029. Anomaly(이상)의 개념 및 종류
		(1)이상(Anomaly)의 개념 : 정규화(Normalization)를 거치지 않은 데이터베이스 내에 데이터들이 불필요하게
					  중복되어 릴레이션 조작 시에 발생하는 예기치 못한 곤란한 현상
		(2)이상의 종류
			- 삽입이상(Insertion Anomaly) : 릴레이션에 데이터를 삽입할 때 의도와는 관계없이 원하지
							않은 값들도 함께 삽입되는 현상
			- 삭제이상(Deletion Anomaly) : 릴레이션에서 한 튜플을 삭제할 때 의도와는 관계없는 값들도
							함께 삭제되는 연쇄 삭제 현상
			- 갱신이상(Update Anomaly) : 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만
						     갱신되어 정보에 모순이 생기는 현상


	- 030. 정규화 과정
		: 비정규 릴레이션 - 도메인의 원자값 -> 1NF - 부분적 함수 종속 제거 -> 2NF - 이행적 함수 종속 제거
		-> 3NF - 결정자이면서 후보키가 아닌 것 제거 -> BCNF - 다치 종속 제거 -> 4NF - 조인 종속성 이용 -> 5NF

		<암기요령>
		정규화라는 출소자가 말했다.
		두부이겨다줘 = 도부이결다조
		도메인이 원자값
		부분적 함수 종속 제거
		이행적 함수 종속 제거
		결정자이면서 후보키가 아닌 것 제거
		다치 종속 제거
		조인 종속성 이용

		(1)함수적 종속 관계 A -> B
		(2)완전 함수적 종속 관계 A -> (B,C)
		(3)이행적 종속 관계 A ->B, B-> C = A -> C

	- 031. SQL의 분류
		(1)DDL(데이터 정의어)
			- SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용하는 언어이다.
			- 데이터베이스 관리자나 설계자가 사용한다
			- 데이타 정의어(DDL)의 3가지 유형
				- CREATE : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의함
				- ALTER : TABLE에 대한 정의를 변경하는 데 사용함
				- DROP : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제함
		(2)DML(데이터 조작어)
			- 데이터베이스 사용자가 응용 프로그램이나 질의어를 통하여 저장된 데이터를 실질적으로
			  처리하는 데 사용하는 언어이다
			- 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다
			- 데이터조작어(DML)의 4가지 유형
				- SELECT : 테이블에서 조건에 맞는 튜플을 검색함
				- INSERT : 테이블에 새로운 튜플을 삽입함
				- DELETE : 테이블에서 조건에 맞는 튜플을 삭제함
				- UPDATE : 테이블에서 조건에 맞는 튜플의 내용을 변경함
		(3)DCL(데이터 제어어)
			- 데이터의 보안, 무결성, 데이터 회복, 병행수행 제어 등을 정의하는 데 사용하는 언어이다
			- 데이터베이스 관리자가 데이터 관리를 목적으로 사용한다
			- 데이터 제어어(DCL)의 종류
				- COMMIT : 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고,
					   데이터베이스 조작 작업이 정상적으로 완료 되었음을 관리자에게 알려줌
				- ROLLBACK : 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구함
				- GRANT : 데이터베이스 사용자에게 사용 권한을 부여함
				- REVOKE : 데이터베이스 사용자의 사용 권한을 취소함

	- 032. CREATE TABLE
		: 기본 테이블을 정의하는 명령문이다
		<표기형식>
		CREATE TABLE 테이블_이름
			(속성명 data_type [NOT NULL],....,
			PRIMARY KEY(기본키_속성명),
			UNIQUE(대체키_속성명),
			FOREIGN KEY(외래키_속성명,...)
				REFERENCES 참조테이블(기본키_속성명),
			CONSTRAINT 제약조건명 CHECK(조건식) );
		- 속성명 : 테이블에 포함될 모든 속성에 대하여 속성명과 그 속성의 data_type, NOT NULL 여부를 지정함
		- PRIMARY KEY : 기본키 속성을 지정함
		- UNIQUE : 대첼키로 사용할 속성명들을 지정함
		- FOREIGN KEY ~ REFERENCES ~
			- 참조할 다른 테ㅣ블과 그 테이블을 참조할 때 사용할 외래키 속성을 지정함
			- 외래키가 지정되면 참조 무결성의 CASCADE 법칙이 적용됨
		- CHECK : 제약 조건을 정의함

	- 033. Select 문
		: 테이블을 구성하는 튜플(행)들 중에서 전체 또는 조건을 만족하는 튜플(행)을 검색하여 주기억장치 상에
		  임시 테이블을 구성시키는 명령문이다.
		<표기형식>
		SELECT Predicate [테이블명.]속성명1,[테이블명.]속성명2,...
		FROM 테이블명1, 테이블명2
		[WHERE 조건]
		[GROUP BY 속성명1, 속성명2, ... ]
		[HAVING 조건]
		[ORDER BY 속성명 [ASC | DESC];

		(1) SELECT 절
			- Predicate : 불러올 튜플 수를 제한할 명령어를 기술함
				ALL : 모든 튜플을 검색할 때 지정하는 것으로 주로 생략함
				DISTINCT : 중복된 튜플이 있으면 그 중 첫 번째 한 개만 검색함
				DISTINCTROW : 중복된 튜플을 검색하지만 선택된 속성의 값이 아닌, 튜플 전체를 대상으로 함
			- 속성명 : 검색하여 불러올 속성(열) 및 수식들을 지정함
				- 기본 테이블을 구성하는 모든 속성을 지정할 때는 '*'를 기술한다
			- 두 개 이상의 테이블을 대상으로 검색할 떄는 반드시 테이블명, 속성명으로 표현해야 한다
		(2) FROM 절
			: 질의에 의해 검색될 데이터들을 포함하는 테이블명을 기술함
		(3) WHERE절 
			: 검색할 조건 기술
		(4) GROUP BY절
			- 특정 속성을 기준으로 그룹화하여 검색할 때 그룹할 속성을 지정한다
			- 일반적으로 GROUP BY 절은 그룹 함수와 함께 사용된다
			- 그룹 함수의 종류
				COUNT(속성명) : 그룹별 튜플 수를 구하는 함수
				MAX(속성명) : 그룹별 최대값을 구하는 함수
				MIN(속성명) : 그룹별 최소값을 구하는 함수
				SUM(속성명) : 그룹별 합계를 구하는 함수
				AVG(속성명) : 그룹별 평균을 구하는 함수
		(5) HAVING절
			: GROUP BY와 함꼐 사용되며, 그룹에 대한 조건을 지정함
		(6) ORDER BY절
			: 특정 속성을 기준으로 정렬하여 검색할 때 사용함
			- 속성명 : 정렬의 기준이 되는 속성명을 기술함
			- [ASC|DESC] : 정렬 방식으로서 'ASC'는 오름차순, 'DESC'는 내림차순임, 생략하면 오름차순으로
				       지정됨


	- 034. 삽입,삭제,갱신문
		(1) 삽입문(INSERT INTO~)
			- 기본 테이블에 새로운 튜플을 삽입할 때 사용한다
			<표현식>
			INSERT
			INTO 테이블명(속성1,속성2,...)
			VALUES(데이터1,데이터2,..);
			- 대응하는 속성과 데이터는 개수와 데이터 형식이 일치해야 한다
			- 기본 테이블의 모든 속성을 사용할 때는 속성명을 생략할 수 있다
			- SELECT문을 사용하여 다른 테이블의 검색 결과를 삽입할 수 있다
		(2) 삭제문(DELETE FROM ~)
			- 기본 테이블에 있는 튜플들 중에서 특정 튜플을 삭제할 떄 사용한다
			<표현식>
			DELETE
			FROM 테이블명
			WHERE 조건;
			- 모든 레코드를 삭제할 때는 WHERE 절을 생략한다
			- 모든 레코드를 삭제하더라도 테이블 구조는 남아 있기 때문에 디스크에서 테이블을 완전히
			  제거하는 DROP과는 다르다
		(3) 갱신문(UPDATE~ SET~)
			- 기본 테이블에 있는 튜플들 중에서 특정 튜플의 내용을 변경할 때 사용한다
			 <표현식>
			UPDATE 테이블명
			SET 속성명 = 데이터[,속성명=데이터]
			WHERE 조건;

	- 035. 내장 SQL(Embedded SQL)
		- 응용 프로그램이 실행될 때 함께 실행되도록 호스트 프로그램 언어로 만든 프로그램에
		  삽입된 SQL이다
		- 내장 SQL 실행문은 호스트 언어에서 실행문이 나타날 수 있는 곳이면 프로그램의 어느
		  곳에서나 사용할 수 있다
		- 일반 SQL문은 수행 결과로 여러 개의 튜플을 반환하는 반면, 내장 SQL은 단 하나의
		  튜플만을 반환한다
		- 내장 SQL문에 의해 반환되는 튜플은 일반 변수를 사용하여 저장할 수 있다
		- Host Program의 컴파일 시 내장 SQL 문은 선행 처리기에 의해 분리되어 컴파일된다
		- 호스트 변수와 데이터베이스 필드의 이름은 같아도 된다
		- 내장 SQL문에 사용된 호스트 변수의 데이터 타입은 이에 대응하는 데이터베이스의 필드
 		  의 SQL 데이터 타입과 일치하여야 한다
		- 내장 SQL문이 실행되면 SQL의 실행 상태가 SQL 상태 변수에 전달된다
		- 호스트 언어의 실행문과 SQL문을 구분시키는 방법
		  (1) 명령문의 구분 : C/C++에서 내장 SQL문은 $세미 콜론(;) 문자 사이에 기술하고,
				      Visual Basic에서는 내장 SQL문 앞에 'EXEC SQL'을 기술함
		  (2) 변수의 구분 : 내장 SQL에서 사용하는 호스트 변수는 변수 앞에 콜론(;)문자를 붙임 	

	- 036. 뷰(View)
		- 사용자에게 접근히 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블
		  로부터 유도된 가상 테이블이다
		- 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주된다
		- 데이터 보정작업, 처리과정 시험 등 임시적인 작업을 위한 용도로 활용된다
		(1) 뷰(View)의 특징
			- 기본 테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를
			  가지며, 조작도 기본 테이블과 거의 같다
			- 가상 테이블이기 때문에 물리적으로 구현되어 있지 않다
			- 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령어
			  가 간단해진다
			- 조인문의 사용을 최소화하여 사용상의 편의성을 최대화한다
			- 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지는 데이터를 안전하게
			  보호할 수 있다
			- 기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야만 삽입, 삭제,
			  갱신 연산이 가능하다
			- 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다
			- 하나의 뷰를 삭제하면 그 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다
		(2) 뷰의 장점
			- 논리적 데이터 독립성을 제공한다
			- 동일 데이터에 대한 동시에 여러 사용자의 상이한 응용이나 요구를 지원해준다
			- 사용자의 데이터 관리를 간단하게 해준다
			- 접근 제어를 통한 자동 보완이 제공된다
		(3) 뷰의 단점
			- 독립적인 인덱스를 가질 수 없다
			- 뷰의 정의를 변경할 수 없다
			- 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따른다
		<뷰 정의문>
			CREATE VIEW 뷰이름[(속성이름[,속성이름])]
			AS SELECT문;
			- SELECT문을 부질의로 사용하여 SELECT문의 결과로서 뷰를 생성한다
			- 뷰질의로서의 SELECT문에는 UNION이나 ORDER BY절을 사용할 수 없다
			- 속성 이름을 기술하지 않으면 SELECT문의 속성 이름이 자동으로 사용된다
		<뷰 삭제문>
			DROP VIEW 뷰이름{RESTRICT | CASCADE};
			- RESTRICT : 뷰를 다른 곳에서 참조하고 있으면 삭제가 취소됨
			- CASCADE : 뷰를 참조하는 다른 뷰나 제약 조건까지 모두 삭제됨

	- 037. 시스템 카탈로그
		- 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
		  이다
		- 데이터베이스에 포함되는 모든 데이터 객체에 관한 정의나 명세에 관한 정보를 유지관리
		  하는 시스템 테이블이다
		- 데이터 정의어의 결과로 구성되는 기본 테이블, 뷰, 인덱스, 패키지, 접근 권한 등의
		  데이터베이스 구조 및 통계 정보를 저장한다
		- 카탈로그들이 생성되면 자료 사전(Data Dictionary)에 저장되기 때문에 좁은 의미로는
		  카탈로그를 자료 사전이라고도 한다
		- 카탈로그에 저장된 정보를 메타 데이터(Meta-Data)라고 한다
		<시스템 카탈로그의 특징>
			- 카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자도 SQL을 이용하여
			  내용을 검색해 볼 수 있다
			- INSERT, DELETE, UPDATE문으로 갱신하는 것은 허용하지 않는다
			- DBMS가 스스로 생성하고 유지한다
			- 카탈로그는 사용자나 SQL문을 실행시켜 기본 테이블, 뷰, 인덱스 등에 변화를
			  주면 시스템이 자동으로 갱신한다
		
	- 038. 트랜잭션
		- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
		  또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다
		- 응용 프로그램이나 사용자가 데이터베이스의 내용을 접근하거나 변경하기 위해 실행되는
		  동작 또는 동작들의 모임이다
		- 데이터베이스 시스템에서 복구 및 병행 수행 시 처리되는 작업의 논리적 단위이다
		(1) Atomicity(원자성)
			- 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지
			  않아야 함
			- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히
			  수행되지 않고 어느 하나라도 에러가 발생하면 트랜잭션 전부가 취소되어야 함
		(2) Consistency(일관성)
			- 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스
			  상태로 변환함
			- 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의
			  상태가 같아야 함
		(3) Isolation(독립성, 격리성)
			- 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션
			  실행중에 다른 트랜잭션의 연산이 끼어들 수 없음
			- 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를
			  참조할 수 없음
		(4) Durability(영속성, 지속성)
			- 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함

	- 039. 자료구조의 분류
		(1) 선형구조 
			: 선형 리스트(배열), 연결 리스트, 스택, 큐, 데크
		(2) 비선형 구조
			: 트리, 그래프

	- 040. 연결 리스트(Linked List)
		- 연결 리스트는 자료들을 임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을
		  이용하여 서로 연결시킨 자료 구조이다
		- 노드의 삽입, 삭제 작업이 용이하다
		- 기억 공간이 연속적으로 놓여 있지 않아도 저장이 가능하다
		- 연결을 위한 링크(포인터) 부분이 필요하기 때문에 순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않다
		- 접근 속도가 느리다
		- 희소 행렬을 링크드 리스트로 표현하면 기억 장소가 절약된다
		- 트리를 표현하기에 적합하다

	- 041. 스택(Stack)
		- 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다
		- 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입 선출(LIFO; Last-In, First-Out)방식으로 자료를
		  처리한다
		- TOP : Stack으로 할당된 기억공간에 가장 마지막으로 삽입된 자료가 기억된 위치를 가리키는 요소,
			스택 포인터라고도 함
		- Bottom : 스택의 가장 밑바닥임
		(1) Stack의 용도
			- 부 프로그램 호출 시 복귀주소를 저장할 때
			- 함수 호출의 순서 제어
			- 인터럽트가 발생하여 복귀주소를 저장할 때
			- 후위 표기법(Postfix Notation)으로 표현된 산술식을 연산할 때
			- 0 주소지정방식 명령어의 자료 저장소
			- 재귀(Recursive) 프로그램의 순서 제어
			- 컴파일러를 이용한 언어 번역 시

	- 042. 스택의 삽입(Push)과 삭제(Pop)
		(1) 삽입(Push)
			Top = Top+1
			if Top > M then Overflow Else X(Top) <- Item
			: 스택 포인터(Top)를 1증가시킨다
			  스택포인터가 스택의 크기보다 크면 Overflow
			  그렇지 않으면 Item이 가지고 있는 값을 스택의 Top위치에 삽입한다
			- M : 스택의 크기
			- Top : 스택 포인터
			- X : 스택의 이름
			- Overflow : 스택으로 할당받은 메모리 부분의 마지막 주소가 M번지라고 할 때, Top Pointer의 값
				     이 M보다 커지면 스택의 모든 기억장소가 꽉 채워져 있는 상태이므로 더 이상 자료를
				     삽입할 수 없어 Overflow를 발생시킴
		(2) 삭제(Pop)
			If Top = 0 Then Underflow Else Item <- X(Top) Top= Top-1
			: 스택 포인터가 0이면 스택의 바닥이어서 더 이상 삭제할 자료가 없으므로 Underflow를 처리한다
			  그렇지 않으면 Top 위치에 있는 값을 Item으로 옮기고 스택 포인터를 1감소시킨다
			- Underflow : Top Pointer가 주소 0을 가지고 있다면 스택에는 삭제할 자료가 없으므로 Underflow
				      를 발생시킴
	 
	- 043. 큐(Queue)
		- 선형 리스트의 한 쪽에서는 삽입 작업이 이루어지고 다른 한 쪽에서는 삭제 작업이 이루어지도록 구성한
		  자료 구조이다.
		- 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO; First-In, First-Out)방식으로 처리한다
		- 시작과 끝을 표시하는 두 개의 포인터를 갖는다
			(1) 프론트(F, Front) 포인터 : 가장 먼저 삽입된 자료의 기억공간을 가리키는 포인터로, 삭제
						      작업을 할 때 사용함
			(2) 리어(R, Rear) 포인터 : 가장 마지막에 삽입된 자료가 위치한 기억장소를 가리키는 포인터로,
						   삽입 작업을 할 때 사용함
		<Queue를 이용하는 예>
		- 창구 업무처럼 서비스 순서를 기다리는 등의 대기 행렬의 처리에 사용한다
		- 운영체제의 작업 스케줄링에 사용한다

	- 044. 데크(Deque)
		- 삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생할 수 있는 자료 구조이다
		- Double Ended Queue의 약자이다
		- Stack과 Queue의 장점만 따서 구성한 것이다
		- 입력이 한 쪽에서만 발생하고 출력은 양쪽에서 일어날 수 있는 입력 제한과 입력은 양쪽에서 일어나고
		  출력은 한 곳에서만 이루어지는 출력 제한이 있다
			(1) 입력 제한 데크 : Scroll
			(2) 출력 제한 데크 : Shelf

	- 045. 트리(Tree)
		- 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 Graph의 특수한 형태로
		  가족의 계보(족보), 연산 수식, 회사 조직 구조도, 히프(Heap) 등을 표현하기에 적합하다
		- 노드(Node) : 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것
		- 근 노드(Root Node) : 트리의 맨 위에 있는 노드
		- 디그리(Degree, 차수) : 각 노드에서 뻗어나온 가지의 수
		- 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수
		- 단말 노드(Terminal Node) = 잎 노드(Leaf Node) : 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
		- 비단말 노드(Non-Terminal Node) : 자식이 하나라도 있는 노드, 즉 디그리가 0이 아닌 노드
		- 자식 노드(Son Node) : 어떤 노드에 연결된 다음 레벨의 노드들
		- 부모 노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드
		- 형제 노드(Brother Node, Sibling) : 동일한 부모를 갖는 노드를
		- Level : 근 노드의 Level을 1로 가정한 후 어떤 Level이 L이면 자식 노드는 L+1 이다
		- 깊이(Depth, Height): 어떤 Tree에서 노드가 가질 수 있는 최대의 레벨

 	- 046. 이진 트리의 운행법
		- 전위(Preorder) 운행 : Root -> Left -> Right 순으로 운행함 A, B, C
		- 중위(Inorder) 운행 : Left -> Root -> Right 순으로 운행함 B, A, C
		- 후위(Postorder) 운행 : Left -> Right -> Root 순으로 운행함 B, C, A

	- 047. 수식의 표기법
		- 전위 표기법(Prefix) : 연산자 -> Left -> Right, +AB
		- 중위 표기법(Infix) : Left -> 연산자 -> Right, A+B
		- 후위 표기법(Postfix) : Left -> RIght -> 연산자, AB+
		<Infix 표기를 Postfix로 바꾸기>
		: Infix로 표시된 수식에서 연산자를 해당 피연산자 두 개의 뒤(오른쪽)에 오도록 이동하면 Postfix가 된다
		X = A / B * ( C + D ) + E  -> X A B / C D + * E + =

	- 048. 정렬(Sort)
		: 정렬(Sort)은 파일을 구성하는 각 레코드들을 특정 키 항목을 기준으로 오름차순(Ascending)
		  또는 내림차순(Descendig)으로 재배열하는 작업이고, 이 과정을 Sorting이라 한다
		(1) 내부 정렬
			- 소량의 데이터를 주기억장치에만 기억시켜서 정렬하는 방식이다
			- 종류 : 히프 정렬, 삽입 정렬, 버블 정렬, 셀 정렬, 선택 정렬, 퀵 정렬,
				 2-Way Merge 정렬, 기수 정렬(=Radix Sort)
		(2) 외부 정렬
			- 대량의 데이터를 보조기억장치에 기억시켜서 정렬하는 방식으로, 대부분 병합
			  정렬(Merge Sort) 기법으로 처리한다
			- 종류 : 밸런스 병합 정렬, 케스캐이드 병합 정렬, 폴리 파즈 병합 정렬, 
				 오실레이팅 병합 정렬
		(3) 정렬 알고리즘 선택 시 고려 사항
			- 데이터의 양
			- 초기 데이터의 배열 상태
			- 키 값들의 분포 상태
			- 소요공간 및 작업시간
			- 사용 컴퓨터 시스템의 특성

	- 049. 주요 정렬 알고리즘의 이해
		(1) 삽입 정렬(Insert Sort)
		(2) 버블 정렬(Bubble Sort)
		(3) 선택 정렬(Selection Sort)
		(4) 2-Way 합병 정렬(Merge Sort)
		(5) 퀵 정렬(Quick Sort)
			- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방식
			- 정렬 방식 중에서 가장 빠른 방식이다
			- 프로그램에서 되부름을 이용하기 때문에 스택(Stack)이 필요하다
			- 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬한다
				- 분할(Divide) : 정렬할 자료들을 기준값인 피봇(Pivot)을 중심으로 2개의 부분집합으로
						 나누는 것
				- 정복(Conquer) : 부분집합의 원소들 중 피봇(Pivot)보다 작은 원소들은 왼쪽, 피봇(Pivot)
						  보다 큰 원소들은 오른쪽 부분집합으로 정렬하는 과정을 거치 데,
						  부분집합의 크기가 더 이상 나누어질 수 없을 때까지 분할과 정복을
						  반복한다
	- 050. 이분 검색(이진 검색)
		- 제어 검색의 일종인 이분 검색은 반드시 순서화된 파일이어야 검색할 수 있다
		- 전체 파일을 두 개의 서브 파일로 분리해 가면서 Key 레코드를 검색한다
		- 찾고자 하는 Key 값을 파일의 중간 레코드 Key 값과 비교하면서 검색한다
		- 중간 레코드 번호(M) : (F+L) / 2 (단, F : 첫 번째 레코드 번호, L : 마지막 레코드 번호)

	- 051. 해싱(Hashing)
		- Hash Table이라는 기억공간을 할당하고, 해시 함수(Hash Function)을 이용하여 레코드 키에 대한 Hash
		  Table 내의 Home Address를 계산한 후 주어진 레코드를 해당 기억장소에 검색하거나 검색 작업을 수행하는
		  방식이다
		- DAM(직접접근방법) 파일을 구성할 때 해싱이 사용되며, 접근 속도는 빠르지만 기억공간이 많이 요구된다
		- 여러가지 검색 방식 중 검색 속도가 가장 빠르다
		- 삽입, 삭제 작업의 빈도가 많을 때 유리한 방식이다
		- 키- 주소 변환 방법이라고도 한다
		(1) 해시 테이블(Hash Table)
			: 레코드를 1개 이상 보관할 수 있는 Home Bucket들로 구성한 기억공간으로, 보조기억장치에 
			  구성할 수도 있고 주기억장치에 구성할 수도 있다
		(2) 버킷(Bucket)
			: 하나의 주소를 갖는 파일의 한 구역을 의미하며, 버킷의 크기는 같은 주소에 포함될 수 있는
			  레코드 수를 의미함
		(3) 슬롯(Slot) 
			: 1개의 레코드를 저장할 수 있는 공간으로 n개의 슬롯이 모여 하나의 버킷을 형성함
		(4) Collision(충돌 현상)
			: 서로 다른 2개 이상의 레코드가 같은 주소를 갖는 현상
		(5) Synonym 
			: 같은 Home Address를 갖는 레코드들의 집합
		(6) Overflow
			- 계산된 Home Address의 Bucket 내에 저장할 기억 공간이 없는 상태
			- Bucket을 구성하는 Slot이 여러 개일 때는 Collision은 발생해도 Overflow는 발생하지 않을 수
			  있음

	- 052. 해시 함수(Hash Function)
		(1) 제산(Divide) 법
			: 코드 키(K)를 해시표(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나눈
			  나머지를 홈 주소로 삼는 방식, 즉 h(K) = K mod Q임
		(2) 제곱(Mid-Square)법
			: 레코드 키 값(K)을 제곱한 후 그 중간 부분의 값을 홈 주소로 삼는 방식
		(3) 폴딩(Folding)법(접지법)
			: 레코드 키값(K)을 여러 부분으로 나눈 후 각 부분의 값을 더하거나 XOR(배타적 논리합)한 값을
			  홈 주소로 삼는 방식
		(4) 기수(Radix) 변환법
			: 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수는 절단하고,
			  이를 다시 주소 범위에 맞게 조정하는 방식
		(5) 대수적 코딩(Algebraic Coding)법
			: 키값을 이루고 있는 각 자리의 비트수를 한 다항식의 계수로 간주하고, 이 다항식을 해시표의
			  크기에 의해 정의된 다항식으로 나눠 얻은 나머지 다항식의 계수를 홈 주소로 삼는 방식
		(6) 계수 분석(Digit Analysis)법(숫자 분석법)
			: 주어진 모든 키 값들에서 키값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한
			  만큼 택해서 홈 주소로 삼는 방식
		(7) 무작위(Random)법
			: 난수(Random Number)를 발생시켜 나온 값을 홈 주소로 삼는 방식

	- 053. 순차 파일(Sequential File) = 순서 파일
		- 입력되는 데이터들을 논리적인 순서에 따라 물리적 연속 공간에 순차적으로 기록하는 방식이다
		- 급여 관리 등과 같이 변동 사항이 크지 않고 기간별로 일괄 처리를 주로 하는 경우에 적합하다
		- 주로 순차 접근이 가능한 자기 테이프에서 사용된다
		(1) 순차 파일의 장점
			- 기록 밀도가 높아 기억공간을 효율적으로 사용할 수 있다
			- 레코드가 키 순서대로 편성되어 취급이 용이하다
			- 매체 변환이 쉬워 어떠한 매체에도 적용할 수 있다
			- 레코드를 기록할 때 사용한 키 순서대로 레코드를 처리하는 경우, 다른 편성법보다 처리 속도가
			  빠르다
		(2) 순차 파일의 단점
			- 파일에 새로운 레코드를 삽입, 삭제, 수정하는 경우 파일 전체를 복사해야 하므로 시간이
			  많이 소요된다
			- 데이터 검색 시 처음부터 순차적으로 하기 때문에 검색 효율이 낮다
		
	- 054. 색인 순차 파일(Indexed Sequential File)
		- 순차 처리와 랜덤 처리가 모두 가능하도록 레코드들을 키 값 순으로 정렬(Sort)시켜 기록하고, 레코드의
		  키 항목만을 모든 색인을 구성하여 편성하는 방식이다
		- 색인을 이용한 순차적인 접근 방법을 제공하여 ISAM(Index Sequential Access Method)이라고도 한다
		- 레코드를 참조하는 경우 색인을 탐색한 후 색인이 가리키는 포인터(주소)를 사용하여 직접 참조할 수 있다
		- 일반적으로 자기 디스크에 많이 사용되며, 자기 테이프에서는 사용할 수 없다
		(1) 색인 순차 파일의 구성
			- 기본 구역(Prime Data Area)
				: 실제 레코드들을 기록하는 부분으로, 각 레코드는 키 값 순으로 저장됨
			- 색인 구역(Index Area)
				: 기본 구역에 있는 레코드들의 위치를 찾아가는 색인이 기록되는 부분으로, 트랙 색인
				  구역, 실린더 색인 구역, 마스터 색인 구역으로 구분할 수 있음
			- 오버플로 구역(Overflow Area)
				: 기본 구역에 빈 공간이 없어서 새로운 레코드의 삽입이 불가능할 때를 대비하여 예비적
				  으로 확보해 둔 부분
				(1) 실린더 오버플로 구역(Cylinder Overflow Area)
					: 각 실린더마다 만들어지는 오버플로 구역으로, 해당 실린더의 기본 구역에서
					  오버플로된 데이터를 기록함
				(2) 독립 오버플로 구역(Independent Overflow Area)
					: 실린더 오버플로 구역에 더 이상 오버플로된 데이터를 기록할 수 없을 때
					  사용할 수 있는 예비 공간으로, 실린더 오버플로 구역과는 별도로 만들어짐
		(2) 색인 순차 파일의 장점
			- 순차 처리와 랜덤 처리가 모두 가능하므로, 목적에 따가 융통성 있게 처리할 수 있다
			- 효율적인 검색이 가능하고 레코드의 삽립, 삭제, 갱신이 용이하다
		(3) 색인 순차 파일의 단점
			- 색인 구역과 오버플로 구역을 구성하기 위한 추가 기억 공간이 필요하다
			- 파일이 정렬되어 있어야 하므로 추가, 삭제가 많으면 효율이 떨어진다
			- 색인을 이용한 엑세스를 하기 때문에 엑세스 시간이 랜덤 편성 파일보다 느리다
	


<<2과목 전자계산기 구조>>

	- 055. 불대수의 기본 공식
		- 교환법칙 : A+B = B+A, A*B = B*A
		- 결합법칙 : A+(B+C) = (A+B)+C
			     A*(B*C) = (A*B)*C
		- 분배법칙 : A*(B+C) = A*B + A*C
			     A+(B*C) = (A+B) * (A+C)
		- 멱등법칙 : A+A = A, A*A = A
		- 보수법칙 : A+(바)A = 1, A*(바)A = 0
		- 항등법칙 : A+0 = A, A+1 = 1, A*0 = 0, A*1 = A
		- 드로르강 : (바)A+(바)B = (바)(A*B), (바)(A*B) = ((바)A+(바)B)
		- 복원법칙 : (바)A=A

	- 056. 논리게이트
		- AND : 입력신호가 모두 1일때 1 출력 <Y=A*B>
		- OR : 입력신호 중 1개만 1이어도 1출력 <Y=A+B>
		- NOT : 입력된 정보를 반대로 변환하여 출력 <Y=!(A)>
		- BUFFER : 입력된 정보를 그대로 출력 <Y=A>
		- NAND : NOT+AND, 즉 AND의 부정 <Y=!A+!B>
		- NOR : NOT+OR, 즉 OR의 부정 <Y=!(AB)>
		- XOR : 입력신호가 모두 같으면 0 한 개라도 틀리면 1출력 <Y=!AB+A!B>
		- XNOR : NOT+XOR, 즉 XOR의 부정 < Y=AB+!A!B>

	- 057. 조합논리회로와 순서논리회로
		- 조합논리회로는 임의의 시간에서의 출력이 이전의 입력에는 관계없이 현재의 입력 조합(0또는 1)으로부터
		  직접 결정되는 논리회로이다. 이해 반해 손서논리회로는 외부로부터의 입력과 현재 상태에 따라 출력이
		  결정된다
		- 조합논리회로의 종류
			: 반가산기, 전가산기, 병렬가산기, 반감산기, 전감산기, 디코더, 인코더, 멀티플렉터, 디멀티플렉서
			  다수결회로, 비교기 등
		- 순서논리회로의 종류 : 플립플롭, 레지스터, 카운터, RAM, CPU등

	- 058. 반가산기(HA; Half Adder)
		- 1Bit 짜리 2진수 2개를 덧셈한 합(S)과 자리올림 수(C)를 구하는 회로이다
		논리식 : Carry = A*B Sum = !AB+A!B (XOR)
		
	- 059. 전가산기(FA; Full Adder)
		- 자리올림 수(C)를 포함하여 1Bit 크기의 2진수 3자리를 더하여 합(Sum)과 자리올림 수(Carry)를 구하는
		  회로이다
		(1) 논리식
			- 합계(Sum) : (A XOR B) XOR C
			- 자리올림(Carry) : (A XOR B)C + AB
		(2) 회로
			- 전가산기는 2개의 반가산기(HA)와 1개의 OR Gate로 구성된다

	- 060. 디코더(Decoder)
		- n Bit의 Code화된 정보를 그 Code의 각 Bit 조합에 따라 2의 n승 개의 출력으로 번역하는 회로이다
		- 명령어의 명령부나 번지를 해독할 때 사용하며, 주로 AND 게이트로 구성된다

	- 061. 플립플롭
		- 플립플롭은 전원이 공급되고 있는 한, 상태의 변화를 위한 신호가 발생할 때까지 현재의 상태를 그대로
		  유지하는 대표적인 순서 논리회로이다
		- 플립플로 1개가 1Bit를 구성하는 2진 셀(Binary Cell)이 된다
		- 반도체 기억장치에서 2진수 1자리값을 기억하는 메모리 소자이다
		- 플립플롭은 레지스터를 구성하는 기본 소자이다
		- 기본적인 플립플롭은 2개의 NAND 또는 NOR 게이트를 이용하여 구성한다
		<종류>
		(1) RS 
			- 플립플롭의 기본으로, S와 R선의 입력을 조절하여 임의의 Bit값을 그대로 유지시키거나, 무조건
			  0 또는 1의 값을 기억시키기 위해서 사용됨
		(2) JK 
			- RS FF에서 S=R=1일 때 동작되지 않는 결점을 보완할 플립플롭
			- RS FF의 입력선 S와 R에 AND 게이트 2개를 추가하여
			  JK FF의 입력선 J와 K로 사용함
			- 모든 플립플롭의 기능을 포함함
		(3) D
			- RS FF의 R선에 인버터(Inverter)를 추가하여 S선과 하나로 묶어서 입력선을 하나만 구성한
			  플립플롭
			- 입력하는 값을 그대로 저장하는 기능을 수행함
		(4) T
			- JK FF의 두 입력선을 묶어서 한 개의 입력선으로 구성한 플립플롭
			- T=0인 경우는 변화가 없고, T=1인 경우에 현재의 상태를 토글(Toggle)시킴, 즉 원 상태와
			  보수 상태의 2가지 상태로만 서로 전환됨
		(5) 마스터-슬레이브(M/S)
			- 출력측의 일부가 입력측에 궤한(FeedBack)되어 유발되는 레이스 현상을 없애기 위해 고안된
			  플립플롭
			- 2개의 플립플롭으로 구성되는 데, 한쪽 회로가 마스터이고 다른 한쪽이 슬레이브의 위치에
			  있어 마스터-슬레이브 플립플롭이라 함

		- 062. 자료 구성의 단위
		(1) 비트(Bit, Binary Digit)
			- 자료(정보) 표현의 최소 단위
			- 2가지 상태(0과 1)를 표시하는 2진수 1자리
		(2) 니블(Nibble)
			- 4개의 비트(Bit)가 모여 1개의 Nibble을 구성함
			- 4비트로 구성되며 16진수 1자리를 표현하기에 적합함
		(3) 바이트(Byte)
			- 문자를 표현하는 최소 단위
			- 8개의 비트(Bit)가 모여 1Byte를 구성함
			- 1Byte는 256가지의 정보를 표현할 수 있음
			- 주소 지정의 단위로 사용됨
		(4) 워드(Word)
			- CPU가 한 번에 처리할 수 있는 명령 단위
			- 반워드(Half Word) : 2Byte
			- 풀워드(Full Word) : 4Byte
			- 더블워드(Double Word) : 8Byte
		(5) 필드(Field)
			- 파일 구성의 최소 단위
			- 의미 있는 정보를 표현하는 최소 단위
		(6) 레코드(Record)
			- 하나 이상의 관련된 필드가 모여서 구성
			- 컴퓨터 내부의 자료 처리 단위로서, 일반적으로 레코드는 논리 레코드(Logical Record)를 의미함
		(7) 블록(Block), 물리 레코드(PhysicalRecord)
			- 하나 이상의 논리 레코드가 모여서 구성
			- 각종 저장 매체와의 입,출력 단위를 의미하며, 일반적으로 물리 레코드(Physical Record)라고 함
		(8) 파일(File)
			- 프로그램 구성의 기본 단위로, 여러 레코드가 모여서 구성됨
		(9) 데이터베이스(Database)
			- 여러 개의 관련된 파일(File)의 집합

	- 063. 진법 변환
		(1) 10진수를 2진수, 8진수, 16진수로 변환
			- 정수 부분
				: 10진수의 값을 변환할 진수로 나누어 더 이상 나눠지지 않을 때까지 나누고, 나머지를
				  역순으로 표시함
			- 소수 부분
				: 10진수의 값에 변환할 진수를 곱한 후 결과의 정수 부분만을 차례대로 표기하되, 소수
				  부분이 0또는 반복되는 수가 나올 때까지 곱하기를 반복함
		(2) 2진수, 8진수, 16진수를 10진수로 변환
			- 정수 부분과 소수 부분의 각 자리를 분리하여 변환하려는 각 진수의 자리값과 자리의 지수승을
			  곱한 결과값을 모두 더하여 계산한다
		(3) 2진수, 8진수, 16진수 상호 변환
			- 2진수를 8진수로
				: 정수 부분은 소수점을 기준으로 왼쪽 방향으로 3자리씩, 소수 부분은 소수점을 기준으로
				  오른쪽 방향으로 3자리씩 묶어서 변환함
			- 2진수를 16진수로
				: 정수 부분은 소수점을 기준으로 왼쪽방향으로 4자리씩, 소수 부분은 소수점을 기준으로
				  오른쪽 방향으로 4자리씩 묶어서 변환함
			- 8진수를, 16진수를 2진수로
				: 8진수 1자리는 2진수 3비트로, 16진수 1자리는 2진수 4비트로 풀어서 변환함
			- 8진수를 16진수로 
				: 8진수를 2진수로 변환한 뒤 2진수를 16진수로 변환함
			- 16진수를 8진수로
				: 16진수를 2진수로 변환한 뒤 2진수를 8진수로 변환함

	- 064. 보수
		- 컴퓨터가 기본적으로 수행하는 덧셈 회로를 이용하여 뺼셈을 수행하기 이해 사용한다
		(1) r의 보수
			- 10진법에는 10의 보수가 있고, 2진법에는 2의 보수가 있음
			- 보수를 구할 숫자의 자리수만큼 0을 채우고 가장 왼족에 1을 추가하여 기준을
			  만듦
		(2) r-1의 보수
			- 10진법에는 9의 보수가 있고, 2진법에는 1의 보수가 있음
			- 10진수 N에 대한 9의 보수는 주어진 숫자의 자릿수 만큼 9를 채워 기준을 만듦
			- 2진수 N에 대한 1의 보수는 주어진 숫자의 자릿수 만큼 1을 채워 기준을 만듦

	- 065. 2진 연산
		- 정수값을 2진수로 변환하여 표현하는 방식이다
		- 표현할 수 있는 범위는 작지만 연산 속도가 빠르다
		- n Bit 크기의 워드가 있을 땐 맨 처음 1Bit는 부호(Sign) 비트로 사용되고 나머지 n-1 Bit에
		  2진수로 표현된 정수값이 저장된다
		- 컴퓨터에서 정수를 표기할 때 크기에 제한을 받는 가장 큰 이유는 워드의 비트 수 때문이다
		- 양수 : 부호 비트에 0을 넣고, 변환된 2진수 값을 Data Bit의 오른쪽에서 왼쪽 순으로 차례로
		  	 남는 자리에 0을 채움
		- 음수 : 음수를 표현할 때는 다음과 같은 3가지 방법을 사용함
			(1) 부호화 절대치법(Signed Magnitude)
				: 양수 표현에 대하여 부호 Bit의 값만 0을 1로 바꿈, 2가지 형태의 0존재(+0, -0)
				- 표현 범위 : (n=8) -127 ~ 127
			(2) 부호화 1의 보수법(Signed 1's Complement)
				: 양수 표현에 대하여 1의 보수를 취함, 2가지 형태의 0 존재(+0, -0)
				- 표현 범위 : (n=8) -127 ~ 127
			(3) 부호화 2의 보수법(Signed 2's Complement)
				: 양수 표현에 대하여 2의 보수를 취함, 한 가지 형태의 0만 존재(+0)
				- 표현 범위 : (n=8) -128 ~ 127

	
	- 066. 10진 연산
		: 10진수 1자리를 2진수 4자리로 표현하는 방식으로, 언팩(Unpack) 연산과 팩(Pack)연산이 있다
		(1) 언팩(Unpack) 연산
			- 존(Zone)형 10진 연산이라고도 한다
			- 연산이 불가능하고, 데이터의 입,출력에 사용된다
			- 1Byte로 10진수 1자리를 표현한다
			- 4개의 존(Zone)비트와 4개의 숫자(Digit)비트를 사용한다
			- 최하위(가장 오른쪽) 바이트의 존(Zone) 부분을 부호로 사용한다
			- Zone 부분 : 무조건 1111을 넣음
			- Digit 부분 : 10진수 1자리를 4Bit 2진수로 표현함
			- Sign 부분 : 양수는 C(1100) , 음수는 D(1101), 부호 없는 양수는 F(1111)로 표현함
		(2) 팩(Pack) 연산
			- 연산이 가능하고, 데이터의 입,출력이 불가능하다
			- 1Byte로 10진수 2자리를 표현한다
			- 최하위(가장 오른쪽) 바이트의 4Bit 부분을 부호로 사용한다
			- Digit부분 : 10진수 1자리를 4Bit 2진수로 표현함
			- Sign부분 : 양수는 C(1100), 음수는 D(1101), 부호 없는 양수는 F(1111)로 표현함

	- 067. 부동 소수점 표현
		: 부동 소수점 방식은 소수점이 포함된 실수 데이터의 표현과 연산에 사용되는 방식이다
		(1) 부동 소수점 방식의 특징
			- 고정 소수점 방식으로 표현하는 것보다 매우 큰 수나 작은 수, 매우 정밀한 수를 적은 비트로
			  표현할 수 있다
			- 과학이나 공학 또는 수학적인 응용에 주로 사용된다
			- 고정 소수점 방식에 비해 연산 시간이 많이 걸린다
			- 지수부와 가수부를 분리하는 정규화 과정이 필요하다
			- 정규화의 목적은 유효 자릿수를 최대로 하여 수의 정밀도를 높이기 위한 것이다
			- 4Byte를 사용하는 단정도와 가수부를 4Byte 추가하여 좀더 정밀하게 표현할 수 있는
			  8Byte 배정도 표현법이 있다
		(2) 부동 소수점 수의 연산 방법
			<1> 덧셈, 뺄셈
				- 0인지의 여부를 조사한다
				- 가수의 위치 조정 : 두 자료의 지수를 비교한 후 소수점의 위치를 이동하여
				  		     지수가 큰 쪽에 맞춘다
				- 가수부 값끼리 더하거나 뺀다
				- 결과를 정규화한다
			<2> 곱셉
				- 0인지의 여부를 조사한다
				- 지수를 더한다
				- 가수를 곱한다
				- 결과를 정규화한다
			<3> 나눗셈
				- 0인지의 여부를 조사한다
				- 부호를 결정한다
				- 피제수가 제수보다 작게 피제수의 위치를 조정한다
				- 지수의 뺄셈을 한다
				- 가수의 나눗셈을 한다


	- 068. 자료의 외부적 표현
		(1) BCD(Binary Coded Decimal, 2진화 10진 코드)
			- 6Bit 코드로 IBM 사에서 개발
			- 1개의 문자를 2개의 Zone 비트와 4개의 Digit 비트로 표현함
			- 6Bit는 64개의 문자를 표현할 수 있음
			- 1Bit의 Parity Bit를 추가하여 7Bit로 사용함
			- 영문 소문자를 표현하지 못함
		(2) ASCII코드(American Standard Code for Information Interchange)
			- 7Bit 코드로 미국 표준협회에서 개발
			- 1개의 문자를 3개의 Zone비트와 4개의 Digit비트로 표현함
			- 128가지의 문자를 표현할 수 있음
			- 1Bit의 Parity Bit를 추가하여 8Bit로 사용함
			- 통신 제어용 및 마이크로 컴퓨터의 기본 코드임
		(3)  EBCDIC(Extended BCD Interchange Code, 확장 2진화 10진 코드)
			- 8Bit 코드로 IBM에서 개발
			- 1개의 문자를 4개의 Zone비트와 4개의 Digit비트로 표현함
			- 256가지의 문자를 표현할 수 있음
			- 1Bit의 Parity Bit를 추가하여 9Bit로 사용함
			- 대형 기종의 컴퓨터에서 사용함

	- 069. 기타 자료의 표현 방식
		(1) BCD 코드
			- 10진수 1자리의 수를 2진수 4Bit로 표현함
			- 4Bit의 2진수 각 Bit가 8,4,2,1 의 자리값을 가지므로 8421 코드라고도 함
			- 대표적인 가중치 코드
			- 문자 코드인 BCD에서 Zone부분을 생략한 형태임
			- 10진수 입, 출력이 간편함
		(2) Excess-3 코드(3초과 코드)
			- BCD+3, 즉 BCD코드에 3을 더하여 만든 코드임
			- 대표적인 자기 보수 코드이며, 비가중치 코드임
		(3) Gray 코드
			- BCD 코드의 인접하는 비트를 X-OR 연산하여 만든 코드
			- 입, 출력장치, A/D 변환기, 주변장치 등에서 숫자를 표현할 때 사용
			- 1Bit만 변화시켜 다음 수치로 증가시키기 떄문에 하드웨어적인 오류가 적음
		(4) 패리티 검사 코드
			- 코드의 오류를 검사하기 위해서 데이터 비트 외에 1Bit 패리티 체크 비트를 추가하는 것으로
			  1Bit의 오류만 검출할 수 있음
			- Odd(기수) Parity : 코드에서 1인 Bit의 수가 홀수가 되도록 0이나 1을 추가함
			- Even(우수) Parity : 코드에서 1인 Bit의 수가 짝수가 되도록 0이나 1을 추가함
		(5) 해밍 코드
			- 오류를 스스로 검출하여 교정이 가능한 코드
			- 1Bit의 오류만 교정할 수 있음
			- 데이터 비트 외에 에러 검출 및 교정을 위한 잉여 비트가 많이 필요함
			- 해밍 코드 중 1,2,4,8,16 ... 2의 n승 번째 비트는 오류 검출을 위한 패리티 비트임
		(6) 허프만 코드
			- 사용되는 문자의 빈도수에 따라 코드의 길이가 달라짐

	- 070. 그레이 코드 변환
		(1) 2진수를 Gray Code로 변환하는 방법
			- 첫 번째 그레이 비트는 2진수의 첫 번재 비트를 그대로 내려쓴다
			- 두 번째 그레이 비트부터는 변경할 2진수의 해당 번째 비트와 그 왼쪽의 비트를 XOR 연산하여 쓴다
		(2) Gray Code를 2진수로 변환하는 방법
			- 첫 번째 2진수 비트는 그레이 코드의 첫 번재 비트를 그대로 내려쓴다
			- 두 번재 2진수 비트부터는 왼족에 구해 놓은 2진수 비트와 변경할 해당 번째 그레이 비트를
			  XOR 연산하여 쓴다

	- 071. 코드의 분류
		(1) 가중치 코드(Weight Code)
			: BCD(8421), 2421, 84-2-1, Biquinary(5043210), 51111, Ring-Counter(9876543210)
		(2) 비가중치 코드(Non-Weight Code)
			: 3초과(Excess-3), Gray, Jonson, 2-Out-of-5, 3-Out-of-5
		(3) 자보수 코드(Self-Complement Code)
			: Excess-3, 2421, 51111, 84-2-1
		(4) 오류 검출용 코드
			: 해밍 코드, 패리티 검사 코드, Biquinary, Ring-Counter, 2-Out-of-5, 3-Out-of-5

	- 072. 중앙처리장치의 구성요소
		(1)제어장치
			- 컴퓨터에 있는 모든 장치들의 동작을 지시하고 제어하는 장치
			- 주기억장치에서 읽어 들인 명령어를 해독하여 해당하는 장치에게 제어신호를 보내
			  정확하게 수행하도록 지시함
			< 제어장치의 구성요소 >
				- 명령 레지스터 
					: 현재 실행중인 명령어의 내용을 기억하고 있는 레지스터
				- 명령 해독기(Decoder) 
					: 명령 레지스터에 있는 명령어를 해독하는 회로
				- 제어신호 발생기, 부호기(Encoder) 
					: 해독된 명령에 따라 각 장치로 보낼 제어 신호를 생성하는 회로
				- 제어 주소 레지스터(CAR)
					: 다음에 실행될 마이크로 명령어의 주소를 저장하는 레지스터로,
					  Mapping의 결과값, 주소필드, 서브루틴 레지스터의 내용들이 적재되어있음
				- 제어 버퍼 레지스터(CBR)
					: 제어 기억장치로부터 읽혀진 마이크로명령어 비트들을 일시적으로
					  저장하는 레지스터
				- 제어 기억장치
					: 마이크로 명령어들로 이루어진 마이크로 프로그램을 저장하는 
					  내부 기억장치
				- 순서 제어 모듈
					: 마이크로 명령어의 실행 순서를 결정하는 회로들의 집합
				- 순차 카운터(Sequence counter)
					: 디코더에 의해 선택된 번호에 해당하는 타이밍 번호를 생성
			- 제어 장치에 입력되는 항목
				: 명령어 레지스터, 플래그, 클록
		(2) 연산장치(ALU)
			- 제어장치의 명령에 따라 실제로 연산을 수행하는 장치
			- 산술연산, 논리연산, 관계연산, 이동(Shift)등의 연산을 수행함
			- 가산기, 누산기(AC : Accumlator), 보수기, 데이터 레지스터, 오버플로 검출기,
			  Shift Resgister 등으로 구성되어 있음
		(3) 레지스터
			- CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시
			  기억장소
			- 플립플롭(Flip-Flop)이나 래치(Latch)들을 병렬로 연결하여 구성함
			- 메모리 중에서 가장 속도가 빠름
			- 레지스터의 크기는 워드를 구성하는 비트 개수만큼의 플립플롭으로 구성되며, 여러 개의
			  플립플롭은 공통 클록의 입력에 의해 동시에 여러 비트의 자료가 저장됨
			- 레지스터를 구성하는 플립플롭은 저장하는 값을 임의로 설정하기 위해 별도의 입력 단자를 
			  추가할 수 있으며, 저장값을 0으로 하는 것을 설정해제(CLR)라 함
			<레지스터 간의 자료 전송>
			- 직렬 전송
				: 직렬 시프트 마이크로 오퍼레이션을 뜻하며, 병렬 전송에 비해 전송속도가 느림
			- 병렬 전송
				: 하나의 클록 펄스 동안에 레지스터 내의 모든 비트, 즉 워드가 동시에 전송되는
				  전송 방식
			- 버스 전송
				: 모든 레지스터들의 공통으로 이용하는 경로로, 병렬 전송에 비해 결선의 수를
				  줄일 수 있다는 장점이 있음

	- 073. 주요 레지스터
		(1) 프로그램 카운터, 프로그램 계수기(PC; Program Counter)
			- 다음 번에 실행할 명령어의 번지를 기억하는 레지스터
			- 분기 명령이 실행되는 경우 그 목적지 주소로 갱신됨
		(2) 명령 레지스터(IR; Instruction Register)
			- 현재 실행중인 명령의 내용을 기억하는 레지스터
		(3) 누산기(AC; Accumulator)
			- 연산된 결과를 일시적으로 저장하는 레지스터로 연산의 중심임
		(4) 상태 레지스터(Status Register), PSWR(Program Status Word Register), 플래그 레지스터
			- 시스템 내부의 순간순간의 상태가 기록된 정보를 PSW라고 함
			- 오버플로, 언더플로, 자리올림, 계산상태(-.+,0), 인터럽트 등의 PSW를 저장하고 있는
			  레지스터
		(5) 메모리 주소 레지스터(MAR; Memory Address Register)
			- 읽기 동작이나 쓰기 동작을 수행할 때 필요한 주기억 장소의 주소를 저장하는 주소 저장용
			  레지스터
		(6) 베이스 레지스터(Base Register)
			- 명령이 시작되는 최초의 번지, 즉 시작 주소를 기억하는 레지스터
		(7) 메모리 버퍼 레지스터(MBR; Memory Buffer Register)
			- 기억장치를 출입하는 데이터가 잠시 기억되는 레지스터로, CPU가 데이터를 처리하기 위해서
			  는 반드시 거쳐야 함
		(8) 인덱스 레지스터(Index Register)
			- 주소의 변경, 서브루틴 연결 및 프로그램에서의 반복 연산의 횟수를 세는 레지스터
			- 명령어 실행 과정에서 명령어가 지정한 번지를 수정하기 위해 사용됨
			- 사용자가 내용을 변경할 수 있음
		(9) 데이터 레지스터(Data Register)
			- 연산에 사용될 데이터를 기억하는 레지스터
		(10) 시프트 레지스터(Shift Register)
			- 저장된 값을 왼쪽 또는 오른쪽으로 1Bit씩 자리를 이동시키는 레지스터
			- 2배 길이 레지스터라고도 함
			- 데이터의 직렬 전송에 사용
		(11) 메이저 스테이터스 레지스터(Major Status Register)
			- CPU의 메이저 상태를 저장하고 있는 레지스터

	- 074. 버스
		- CPU, 메모리, I/O 장치 등과 상호 필요한 정보를 교환하기 위해 연결하는 공동의 전송선
		- 컴퓨터 내부 회로에서 버스를 사용하는 가장 큰 목적은 결선의 수를 줄이기 위해서이다
		<버스의 종류>
		(1) 전송하는 정보에 따른 버스의 분류
			- 주소 버스(Address Bus)
				: CPU가 메모리나 입, 출력 기기의 번지를 지정할 때 사용하는 단방향 전송선
			- 자료 버스(Data Bus)
				: CPU와 메모리 또는 입출력 기기 사이에서 데이터를 전송하는 양방향 전송선
			- 제어 버스(Control Bus)
				: CPU의 현재 상태나 상태 변경을 메모리 또는 입, 출력에 알리는 제어 신호를
				  전송하는데 사용하는 양방향 전송선
		(2) 위치에 따른 버스의 분류
			- 내부 버스
				: CPU 및 메모리 내에 구성된 버스
			- 외부 버스
				: 주변 입, 출력장치에 구성된 버스

	- 075. 명령어의 구성
		(1) 연산자부(Operation Code부)
			- 수행해야 할 동작에 맞는 연산자를 표시하며, 흔히 OP-Code부 라고 한다
			- 연산자부의 크기(비트 수)는 표현할 수 있는 명령의 종류를 나타내는 것으로, n Bit면
			  최대 2의 n승 개의 명령어를 사용할 수 있다
			- 모드(Mode)부 : 주소부의 유효 주소가 결정되는 방법을 지정하며, 모드 비트가 0이면 직접,
					  1이면 간접임
		(2) 자료부(Operand부), 주소부
			- 실제 데이터에 대한 정보를 표시하는 부분이다
			- 기억장소의 주소, 레지스터 번호, 사용할 데이터 등을 표시한다
			- 주소부의 크기는 메모리의 용량과 관계가 있다
			- 자료부의 길이가 n Bit라면 최대 2의 n승 개의 기억장소를 주소로 지정할 수 있다

	- 076. 연산자(Operation Code)의 기능
		(1) 함수 연산 기능
			- 산술 연산 : ADD, SUB, MUL, DIV, 산술 SHIFT 등
			- 논리 연산 : NOT, AND, OR, XOR 논리적 SHIFT, ROTATE, COMPLEMENT, CLEAR, SET 등
		(2) 자료 전달 기능
			- CPU와 기억장치 사이에서 정보를 교환하는 기능
			- Load : 기억장치에 기억되어 있는 정보를 CPU로 꺼내오는 명령
			- Store : CPU에 있는 정보를 기억장치에 기억시키는 명령
			- Move : 레지스터 간에 자료를 전달하는 명령
			- Push : 자료를 스택에 저장하는 명령
			- Pop : 스택에서 자료를 꺼내오는 명령
		(3) 제어기능
			- 명령어의 실행 순서를 변경시킬 때 사용하는 기능
			- 무조건 분기 명령 : GOTO, Jump(JMP) 등
			- 조건 분기(Branch) 명령 : IF 조건, SPA, SNA, SZA 등
			- Call : 부 프로그램 호출
			- Return : 부 프로그램에서 메인 프로그램으로 복귀
		(4) 입,출력 기능
			- CPU와 I/O장치, 또는 메모리와 I/O 장치 사이에서 자료를 전달하는 기능
			- INPUT : 입,출력장치의 자료를 주기억장치로 입력하는 명령
			- OUTPUT : 주기억장치의 자료를 입,출력장치로 출력하는 명령

	- 077. 피연산자의 수에 따른 연산자의 분류
		- NOT A처럼 피연산자가 1개만 필요한 연산자들 단항 연산자라 하고, A+B처럼 피연산자가 2개 필요한
		  연산자를 이항 연산자라 한다
		(1) 단항 연산자(Unary Operator)
			: NOT, COMPLEMENT, SHIFT, ROTATE, MOVE, CLEAR 등
		(2) 이항 연산자(Binary Operator)
			: 사칙 연산, AND, OR, XOR, XNOR

	- 078. 연산
		(1) AND(Masking Operation)
			- 특정 문자 또는 특정 Bit를 삭제(Clear) 시키는 명령으로 Masking 명령이라고 함
			- 삭제할 부분의 Bit를 0과 AND시켜서 삭제하는데, 대응시키는 0인 Bit를 Mask Bit라고 함
		(2) OR(Selective Set)
			- 특정 문자를 삽입하거나 특정 Bit에 1을 세트시키는 명령으로 Selective Set 연산이라고도
			  함
			- 삽입하거나 세트시킬 Bit에 삽입할 문자 코드 또는 1을 OR 연산시킴
		(3) XOR(Compare, 비교)
			- 2개의 데이터를 비교하거나 특정 비트를 반전시킬 때 사용함
			- 2개의 데이터를 XOR 연산하여 결과에 1Bit라도 1이 있으면 서로 다른 데이터임
			- 반전시킬 때는 반전시킬 비트와 1을 XOR 시킴
		(4) NOT(Complement, 보수)
			- 각 비트의 값을 반전시키는 연산으로 보수를 구할 때 사용함
		(5) 논리 Shift
			- 왼쪽 또는 오른쪽으로 1Bit씩 자리를 이동시키는 연산으로 데이터의 직렬 전송(Serial Transfer)
			  에 사용함
			- 삽입되는 자리는 무조건 0임
		(6) Rotate
			- Shift에서 밀려 나가는 비트의 값을 반대편 값으로 입력하는 연산
			- 문자 위치를 변환할 때 이용
		(7) 산술 Shift
			- 부호(Sign)를 고려하여 자리를 이동시키는 연산, 2n승 으로 곱하거나 나눌 때 사용함
			- 왼쪽으로 n Bit Shift하면 원래 자료에 2n승을 곱한 값과 같음
			- 오른쪽으로 n Bit Shfit하면 원래 자료를 2n승으로 나눈 값과 같음
			- 홀수를 오른쪽으로 한 번 Shift하면 0.5의 오차가 발생함

	- 079. 연산자의 우선순위
		- 관계식에 연산자가 혼합되어 나오면 우선순위는 산술>관계>논리 순이며 각각은 다음과 같다
		(1) 산술 연산자 : ^(거듭제곱) > x(곱셉), /(나눗셈) > +,-
		(2) 관계 연산자 : =, >, <. => (우선순위가 모두 같음)
		(3) 논리 연산자 : NOT > AND > OR
		- 우선 순위가 같은 연산자가 혼합되어 나오면 연산순서는 왼쪽에서 오른쪽으로 진행된다

	- 080. 명령어 형식
		(1) 3번지 명령어
			- Operand부가 3개로 구성되는 명령어 형식으로 여러개의 범용 레지스터(GPR)를 가진 컴퓨터
			  에서 사용함
			- 연산의 결과는 Operand 3에 기록됨
			- 연산 시 원시 자료를 파괴하지 않음
			- 다른 형식의 명령어를 이용하는 것보다 프로그램 전체의 길이를 짧게 할 수 있음
			- 전체 프로그램 실행 시 명령 인출을 위하여 주기억장치를 접근하는 횟수가 줄어들어 프로그램
			  실행속도를 단축시킴
		(2) 2번지 명령어
			- Operand부가 두 개로 구성되는, 가장 일반적으로 사용되는 명령어 형식임
			- 여러 개의 범용 레지스터를 가진 컴퓨터에서 사용함
			- 실행 속도가 빠르고 기억 장소를 많이 차지하지 않음
			- 3주소 명령에 비해 명령어의 길이가 짧음
			- 계산 결과가 기억장체 기억되고 중앙처리장치에도 남아 있어서 계산 결과를 시험할 필요가
			  있을 때 시간이 절약됨
			<단점>
				- 연산의 결과는 주로 Operand1에 저장되므로 Operand1에 있던 원래의 자료가 파괴됨
				- 전체 프로그램의 길이가 길어짐
		(3) 1번지 명령어
			- Operand부가 1개로 구성되어 있음
			- AC(Accumulator, 누산기)를 이용하여 명령어를 처리함
		(4) 0번지 명령어
			- Operand부 없이 OP-Code부만으로 구성됨
			- 모든 연산은 Stack 메모리의 Stack Pointer가 가리키는 Operand를 이용하여 수행함
			- 수식을 계산하기 위해서는 우선, 수식을 Postfix(역 Polish) 형태로 변경해야 함
			- 모든 연산은 스택에 있는 자료를 이용하여 수행하기 때문에 스택 머신(Stack Machine)이라
			  고도 함
			- 원래의 자료가 남지 않음
	
	- 081. 주소지정방식의 종류
		(1) 암시적 주소 지정방식(Implied Mode)
			- 명령 실행에 필요한 데이터의 위치를 지정하지 않고 누산기나 스택의 데이터를 묵시적으로
			  지정하여 사용함
			- 오퍼랜드가 없는 명령이나 PUSH R1처럼 오퍼랜드가 1개인 명령어 형식에 사용됨
		(2) 즉치(즉시)적 주소 지정방식(Immediate Mode)
			- 명령어 자체에 오퍼랜드(실제 데이터)를 내포하고 있는 방식
			- 별도의 기억장소를 액세스하지 않고 CPU에서 곧바로 자료를 이용할 수 있어서 실행속도가
			  빠르다는 장점이 있음
			- 명령어의 길이에 영향을 받으므로 표현할 수 있는 데이터 값의 범위가 제한적임
		(3) 직접 주소 지정방식(Direct Mode)
			- 명령의 주소부(Operand)가 사용할 자료의 번지를 표현하고 있는 방식
			- 명령의 Operand부에 표현된 주소를 이용하여 실제 데이터가 기억된 기억장소에 직접 사상
			  시킬 수 있음
			- 주소 부분에 실제 사용할 데이터의 유효 주소를 적기 때문에 주소 길이에 제약을 받음
			- 기억 용량이 2n승개의 Word인 메모리 시스템에서 주소를 표현하려면 n비트의 Operand부가
			  필요함
			- 명령의 Operand부에 데이터를 가지고 있는 레지스터의 번호를 지정하면 레지스터 
			  모드라고 함
		(4) 간접 주소 지정방식(Indirect Mode)
			- 명령어에 나타낼 주소가 명령어 내에서 데이터를 지정하기 위해 할당된 비트
			  (Operand 부의 비트) 수로 나타낼 수 없을 때 사용하는 방식
			- 명령의 길이가 짧고 제한되어 있어도 긴 주소에 접근 가능함
			- 명령어 내의 주소부에 실제 데이터가 저장된 장소의 번지를 가진 기억장소의 번지를 
			  표현하므로, 최소한 주기억장치를 2번 이상 접근하여 데이터가 있는 기억장소에 도달함
			- 명령의 Operand부에 데이터의 주소를 가지고 있는 레지스터의 번호를 지정하면 레지스터
		(5) 계산에 의한 주소 지정방식
			- Operand부와 특정 레지스터의 값이 더해져서 유효주소를 계산하는 방식
			- 상대(Relative) 주소 지정방식
				- 명령어의 주소 부분+PC
				- 분기 명령에 많이 사용됨
			- Base Register Mode : 명령어의 주소 부분+ Base Register
			- Index Register Mode : 명령어의 주소 부분+ Index Register
			- 계산에 의한 주소지정방식은 전체 기억장치의 주소를 사용해야 하는 일반적인
			  주소지정방식에 비해 적은 수의 비트를 사용하고, 레지스터 지정필드 없이 묵시적으로
			  레지스터를 지정하여 사용하기 때문에 데이터의 주소를 분류할 때 약식 주소라고 함
			  간접 모드라고 함

	- 082. 마이크로 오퍼레이션(Micro Operation)
		(1) 마이크로 오퍼레이션의 정의
			- Instruction을 수행하기 위해 CPU 내의 레지스터와 플래그가 의미 있는 상태 변환을 하도록
			  하는 동작이다
			- 기억장치로부터 인출하여 해독된 명령어를 실행하기 위해 제어 신호를 발생시키는 각 단계의
			  세부 동작을 말한다
			- 레지스터에 저장된 데이터에 의해 이루어지는 동작이다
			- 한 개의 Clock 펄스 동안 실행되는 기본 동작이다
			- 마이크로 오퍼레이션의 순서를 결정하기 위하여 제어 장치가 발생하는 신호를 제어 신호라고 한다
			- 마이크로 오퍼레이션은 Instruction 실행과정에서 한 단계씩 이루어지는 동작으로, 한 개의 
			  Instruction은 여러 개의 Micro Operation이 동작되어 실행된다
		(2) 마이크로 사이클 타임(Micro Cycle Time)
			- 한 개의 Micro Operation을 수행하는 데 걸리는 시간
			- CPU Cycle Time 또는 CPU Clock Time이라고도 하며, CPU 속도를 나타내는 척도로 이용됨
		(3) 마이크로 오퍼레이션 형식
			- 연산 필드가 두 개인 경우 동시에 두 개의 연산들이 수행된다
			- 조건 필드는 분기에 사용될 조건 플래그를 지정한다
			- 분기 필드는 분기의 종류와 다음에 실행할 마이크로 명령어 주소를 결정하는 방법을 명시한다
			- 주소 필드는 분기가 발생하는 경우를 위하여 목적지 마이크로 명령어의 주소를 가지고 있다
		(4) 제어 와드와 마이크로 프로그램
			- 제어 와드
				: 레지스터의 선택과 산술 논리 연산장치의 역할을 결정하고, 어떤 마이크로 연산을 할
				  것인가를 결정하는 비트의 모임을 제어 워드라고 함, 제어 워드는 마이크로 명령어
				  라고도 함
			- 마이크로 프로그램
				: 어떤 명령을 수행할 수 있도록 구성된 일련의 제어 워드가 특수한 기억장치 속에
				  저장될 때 이를 마이크로 프로그램이라고 함


	- 083. Micro Cycle Time 부여 방식
		- 한 개의 Micro Operation을 수행하는 데 걸리는 시간을 Micro Cycle Time이라 한다
		- Micro Cycle Time은 CPU Cycle Time 또는 CPU Clock Time이라고도 하며, CPU 속도를 나타내는 척도로
		  이용한다
		(1) 동기 고정식(Synchronous Fixed)
			- 모든 마이크로 오퍼레이션의 동작 시간이 같다고 가정하여 CPU Clock의 주기를 Micro Cycle Time
			  과 같도록 정의하는 방식
			- 모든 마이크로 오퍼레이션 중에서 동작 시간이 가장 긴 마이크로 오퍼레이션의 동작 시간을
			  Micro Cycle Time으로 정함
			- 모든 마이크로 오퍼레이션의 동작 시간이 비슷할 때 유리한 방식임
			- 장점 : 제어기의 구현이 단순함
			- 단점 : CPU의 시간 낭비가 심함
		(2) 동기 가변식(Synchronous Variable)
			- 동작 시간이 유사한 Micro Operation들끼리 그룹을 만들어, 각 그룹별로 서로 다른 Micro Cycle
			  Time을 정의하는 방식
			- 동기 고정식에 비해 CPU 시간 낭비를 줄일 수 있는 반면, 제어기의 구현은 조금 복잡함
			- 마이크로 오퍼레이션의 동작 시간이 현저하게 차이 날 때 유리함(정수배)
		(3) 비동기식(Asynchronous)
			- 모든 마이크로 오퍼레이션에 대하여 서로 다른 Micro Cycle Time을 정의하는 방식
			- CPU의 시간 낭비는 전혀 없으나 제어기가 매우 복잡해지기 때문에 실제로는 거의 사용하지 않음

	- 084. 메이저 스테이트
		- 현재 CPU가 무엇을 하고 있는가를 나타내는 상태로서 Fetch, Indirect, Execute, Interrupt 이렇게 4개의
		  상태가 있다
		- CPU는 메이저 스테이트의 4가지 단계를 반복적으로 거치면서 동작을 수행한다
		- 메이저 스테이트는 메이저 스테이트 레지스터를 통해서 알 수 있다
		- Major Cycle 또는 Machine Cycle이라고도 한다

	- 085. 인출 단계(Fetch Cycle)
		- 명령어를 주기억장치에서 중앙처리장치의 명령 레지스터로 가져와 해독하는 단계로, 명령이 실행되기 위해
		  서 가장 먼저 수행되는 동작이다
		- 읽어와 해석된 명령어가 1Cycle 명령이면 이를 수행한 후 다시 Fetch Cycle로 변천한다
		- 1Cycle 명령이 아니면, 해석된 명령어의 모든 비트에 따라 직접주소와 간접주소를 판단한다
		<동작순서 Micro Operation>
			- MAR < PC : PC에 있는 번지를 MAR에 전송시킴
			- MBR < M[MAR] : 메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
			- PC < PC+1 : 다음에 실행할 명령의 위치를 지정하기 위해 PC의 값을 1증가 시킴
			- IR < MBR[OP] : 명령어의 OP-CODE 부분을 명령 레지스터에 전송함
					 현재 MBR에는 주기억장치에서 읽어온 명령이 들어 있음
			- I < MBR[I] : 명령어의 모든 비트를 플립플롭 I에 전송함
			- F < I : I가 0이면 F 플립플롭에 1전송하여 Excecute 단계로 변천하고, I가 1이면 R 플립플롭에 
   			or R < I  1을 전송하여 Indirect 단계로 변천함			
		
	- 086. 간접 단계(Indirect Cycle)
		- Fetch 단계에서 해석된 명령의 주소부가 간접주소인 경우 수행된다
		- Fetch 단계에서 해석한 주소를 읽어온 후 그 주소가 간접주소이면 유효주소를 계산하기 위해 다시 Indirect
		  단계를 수행한다
		- 간접주소가 아닌 경우에는 명령어에 따라 Execute 단계 또는 Fetch 단계로 이동할지를 판단한다
		<동작순서 Micro Operation>
			- MAR < MBR[AD] : MBR에 있는 명령어의 번지 부분을 MAR에 전송함
			- MBR < M[MAR] : 메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
			- No Operation : 동작 없음
			- F < 1, R < 0 : F에 1, R에 0을 전송하여 Execute 단계로 변천함

	- 087. 인터럽트 단계(Interrupt Cycle)
		- 인터럽트 발생 시 복귀주소(PC)를 저장시키고, 제어 순서를 인터럽트 처리 프로그램의 첫 번째 명령으로
		  옮기는 단계이다
		- 인터럽트 단계를 마친 후에는 항상 Fetch 단계로 변천한다
		- Interrupt가 발생할 때만 실행되어 다른 일을 처리하고 돌아오기 때문에 하드웨어로 실현되는 서브부틴
		  (부 프로그램)의 호출이라고도 한다
		<동작순서 Micro Operation>
			- MBR[AD] < PC : PC가 가지고 있는, 다음에 실행할 명령의 주소를 MBR의 주소 부분으로 전송함
			- PC < 0 : 복귀주소를 저장할 0번지를 PC에 전송함
			- MAR < PC : PC가 가지고 있는 값 0번지를 MAR에 전송함
			- PC < PC+1 : 인터럽트 처리 루틴으로 이동할 수 있는 인터럽트 백터의 위치를 지정하기 위해
				      PC의 값을 1증가시켜 1로 세트시킴
			- M[MAR] < MBR : MBR이 가지고 있는, 다음에 실행할 명령의 주소를 메모리의 MAR이 가리키는 위치
					 (0번지)에 저장함
			- IEN < 0 : 인터럽트 단계가 끝날 때까지 다른 인터럽트가 발생하지 않게 IEN에 0을 전송함
			- F < 0,R < 0 : F에 0, R에 0을 전송하여 Fetch 단계로 변천함

	 - 088. 주요 명령의 마이크로 오퍼레이션
		(1) ADD : AC <- AC + M[AD]
			- MAR < MBR[AD] : MBR에 있는 명령어의 번지 부분을 MAR에 전송함
			- MBR < M[MAR] : 메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
			- AC <- AC + MBR : 누산기의 값과 MBR의 값을 더해 누산기에 전송함
		(2) LDA(Load to AC) : AC <- M[AD]
			- MAR < MBR[AD] : MBR에 있는 명령어의 번지 부분을 MAR에 전송함
			- MBR < M[MAR] : 메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
			- AC < 0 : AC에 0을 전송하여 AC를 초기화함
			- AC < AC + MBR : 메모리에서 가져온 MBR과 AC를 더해 AC에 전송함
				     	  초기화된 AC에 더해지므로 메모리의 값을 AC로 불러오는 것이 됨
		(3) STA(Store AC) : M[AD] < AC
			- MAR < MBR[AD] : MBR에 있는 명령어의 번지 부분을 MAR에 전송함
			- MBR < AC : AC의 값을 MBR에 전송함
			- M(MAR) < MBR : MBR의 값을 메모리의 MAR이 지정하는 위치에 전송함
		(4) ISZ(Increment and Skip if Zero)
			- MAR < MBR[AD] : MBR에 있는 명령어의 번지 부분을 MAR에 전송함
			- MBR < M[MAR] : 메모리에서 MAR이 지정하는 위치의 값을 MBR에 전송함
			- MBR < MBR+1 : MBR의 값을 1증가시킴
			- M[MAR] < MBR : MBR의 값을 메모리의 MAR이 지정하는 위치에 전송함
			 IF(MBR=0) THEN  MBR의 값이 0이면 다음 명령을 수행함
			  <- PC+1

	- 089. 제어장치의 비교
		- 제어장치는 필요한 마이크로 연산들이 연속적으로 수행할 수 있도록 
		  제어 신호를 보내는 역할을 한다
		구분		고정배선 제어장치		마이크로 프로그래밍 기법
		반응속도		고속				저속	
		회로 복잡도		복잡				간단
		경제성			비경제성			경제적
		융통성			없음				있음
		구성			하드웨어			소프트웨어
		<마이크로 프로그램>
			- CPU 내의 제어장치를 설계하는 프로그램으로, 각종 제어신호를 발생시키는 여러 개의
			  마이크로 인스트럭션으로 작성된다
			- 컴퓨터 시스템의 제작 단계에서 ROM에 제작된다
			- 소프트웨어적인 요소보다 하드웨어적인 요소가 많아 펌웨어(Firmware)라고도 불린다
			- 제어기를 구성하는 방법으로 마이크로 프로그램이 이용될 수 있다


	- 090. 입,출력장치의 구성
		(1) 입,출력 제어장치
			- 입,출력장치와 컴퓨터 사이의 자료 전송을 제어하는 장치로, 데이터 버퍼 레지스터를
			  이용하여 두 장치 간의 속도 차를 조절한다
			- DMA, 채널, 입,출력 프로세서, 입,출력 컴퓨터 등이 입,출력 제어장치에 해당한다
		(2) 입,출력 인터페이스
			- 동작 방식이나 데이터 형식이 서로 다른 컴퓨터 내부의 주기억장치나 CPU의 레지스터와
			  외부 입,출력장치 간의 2진 정보를 원활하게 전송하기 위한 방법을 제공한다
		(3) 입,출력 버스
			- 주기억장치와 입,출력장치 사이의 데이터 전송을 위해 모든 주변장치의 인터페이스에 
			  공통으로 연결된 버스이다
			- 입,출력 버스는 데이터버스, 주소버스, 제어버스로 구성된다
		<입,출력장치의 종류>
			(1) 입력장치
				- 키보드, 마우스, 스캐너, OMR, OCR, MICRBAR(Bar Code Reader), 마이크로 필름
				  입력장치(CIM:Computer Input Microfilm), 라이트 펜, 터치스크린, 디지타이저 등
			(2) 출력장치
				- 모니터, 프린터, 플로터, 마이크로 필름 출력장치(COM:Computer Output Microfilm)
				  등
			(3) 보조기억장치(입,출력 겸용 장치)
				- 자기 디스크, 자기 테이프, 자기 드럼, 하드디스크, 플로피디스크 등		

	- 091. 기억장치와 입,출력장치의 동작차이
		- 기억장치는 처리속도가 nano단위인 전자적인 장치이고, 입,출력 장치는 밀리의 단위인 기계적인
		  장치이므로 동작 방식에는 많은 차이가 있다
		비교항목		입,출력장치		기억장치
		동작의속도		느리다			빠르다
		동작의자율성		타율/자율		타율
		정보의단위		Byte(문자)		Word
		착오 발생률		많다			적다

	- 092. 스풀링(SPOOLING)
		- Simultaneous Peripheral Operation On-Line의 약자이다
		- 다중 프로그래밍 환경하에서 용량이 크고 신속한 엑세스가 가능한 디스크를 이용하여
		  각 사용자 프로그램이 입,출력할 데이터를 직접 I/O장치로 보내지 않고 디스크에 모았다가
		  나중에 한꺼번에 입,출력함으로써 입,출력장치의 공유 및 상대적으로 느린 입,출력장치의
		  처리속도를 보완하는 기법이다
		- 스풀링은 고속의 CPU와 저속의 입,출력장치가 동시에 독립적으로 동작하게 하여 높은 효율로
		  여러 작업을 병행 작업할 수 있도록 해줌으로써 다중 프로그래밍 시스템의 성능 향상을 
		  가져올 수 있다
		- 스풀링은 디스크 일부를 매우 큰 버퍼처럼 사용한다
		<스풀링과 버퍼링의 비교>
		- 버퍼링도 입,출력장치와 CPU간의 속도 차이를 해결하기 위해 사용하는 목적은 같지만 다음과 
		  같은 점이 스풀링과 다르다
			구분		버퍼링		스풀링
			저장위치	주기억장치	보조기억장치
			운영방식	단일 작업	다중 작업
			구현방식	하드웨어	소프트웨어

	- 093. 입,출력(Input-Output)제어 방식
		(1) Programmed I/O(폴링)
			- 원하는 I/O가 완료되었는지의 여부를 검사하기 위해서 CPU가 상태 Flag를 계속 조사하여
			  I/O가 완료 되었으면 MDR(MBR)과 AC 사이의 자료 전송을 CPU가 직접 처리하는 I/O 방식
			  이다
			- 입,출력에 필요한 대부분의 일을 CPU가 해주므로 인터페이스는 MDR, Flag, 장치번호 디코더
			  로만 구성하면 된다
			- I/O 작업 시 CPU는 계속 I/O 작업에 관여해야 하기 때문에 다른 작업을 할 수 없다는
			  단점이 있다
		(2) Interrupt I/O
			- 입,출력을 하기 위해 CPU가 계속 Flag를 검사하지 않고, 데이터를 전송할 준비가 되면
			  입,출력 인터페이스가 컴퓨터에게 알려 입,출력이 이루어지는 방식이다
			- 입,출력 인터페이스는 CPU에게 인터럽트 신호를 보내 입,출력이 있음을 알린다
			- CPU가 계속 Flag를 검사하지 않아도 되기 때문에 Programmed I/O보다 효율적이다
		(3) DMA(Direct Memory Access)에 의한 I/0
			- 입,출력장치가 직접 주기억장치를 접근(Access)하여 Data Block을 입,출력하는 방식으로
			  입,출력 전송이 CPU의 레지스터를 경유하지 않고 수행된다
			- CPU는 I/O에 필요한 정보를 DMA 제어기에 알려서 I/O동작을 개시시킨 후 I/O동작에 더
 			  이상 간섭하지 않고 다른 프로그램을 할당하여 수행한다
			- 입,출력 자료 전송 시 CPU를 거치지 않기 때문에 CPU의 부담 없이 보다 빠른 데이터의
			  전송이 가능하다
			- 인터럽트 신호를 발생시켜 CPU에게 입,출력 종료를 알린다
			- Cycle Steal 방식을 이용하여 데이터를 전송한다
			- CPU에서 DMA 제어기로 보내는 자료
				- DMA를 시작시키는 명령
				- 입,출력 하고자 하는 자료의 양
				- 입력 또는 출력을 결정하는 명령
			- DMA의 구성 요소
				- 인터페이스 회로 : CPU와 입, 출력 장치와의 통신 담당
				- 주소 레지스터 : 기억장치의 위치 지정을 위한 번지 기억
				- 워드 카운트 레지스터 : 전송되어야 할 워드의 수를 표시함
				- 제어 레지스터 : 전송 방식 결정
				- 데이터 버스 버퍼, 주소 버스 버퍼 : 전송에 사용할 자료나 주소를 임시로 기억함
		(4) Channel에 의한 I/O
			- I/O를 위한 특별한 명령어를 I/O 프로세서에게 수행토록하여 CPU 관여 없이 주기억장치와 
 			  입,출력장치 사이에서 입,출력을 제어하는 입,출력 전용 프로세서(IOP) 이다
			- DMA 방법으로 입,출력을 수행하므로 DMA의 확장된 개념으로 볼 수 있다
			- DMA 제어기의 한계를 극복하기 위하여 고안된 방식이다
			- 채널 제어기는 채널 명령어로 작성된 채널 프로그램을 해독하고 실행하여 입,출력 동작을
			  처리한다
			- CPU로부터 입,출력 전송을 위한 명령어를 받으면 CPU와는 독립적으로 동작하여 입,출력을
			  완료한다
			- 주기억장치에 기억되어 있는 채널 프로그램의 수행과 자료의 전송을 위하여 주기억장치에
			  직접 접근한다
			- I/O 장치는 제어장치를 통해 채널과 연결된다
			- I/O 채널은 CPU의 I/O 명령을 수행하지 않고 I/O 채널 내의 특수목적 명령을 수행한다
			- CPU와 인터럽트로 통신한다
			<채널의 종류>
				- Selector Channel : 고속 입,출력장치(자기 디스크, 자기 테이프, 자기 드럼)
						     1개와 입,출력하기 위해 사용함
				- Multiplexer Channel : 저속 입,출력장치(카드리너, 프린터) 여러 개를 동시에
							제어하는 채널
				- Block Multiplexer Channel : 동시에 여러 개의 고속 입,출력장치를 제어함
			<Cycle Steal>
				- 데이터 채널(DMA 제어기)과 CPU가 주기억장치를 동시에 Access할 때 우선순위를
				  데이터 채널에게 주는 방식입니다
				- Cycle Steal은 한 번에 한 데이터 워드를 전송하고 버스의 제어를 CPU에게
				  돌려줍니다
				- Cycle Steal을 이용하면 입,출력 자료의 전송을 빠르게 처리해 주는 장점이 
				  있습니다
				- Cycle Steal 시 중앙처리장치는 메모리 참조가 필요 없는 오퍼레이션을 계속
				  수행합니다

	- 094. 인터럽트의 종류 및 발생 원인
		- 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행중인 작업을 즉시 중단하고,
		  발생된 상황을 우선 처리한 후 실행중이던 작업으로 복귀하여 계속 처리하는 것, 일명 "끼어들기"
		  라고도 한다
		- 인터럽트 서비스 루틴을 실행할 때, 인터럽트 플래그(IF)를 0으로 하면 인터럽트 발생을 방지할 수
		  있다
		- 인터럽트는 외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트로 분류하는데, 외부나 내부 인터
		  럽트는 CPU의 하드웨어에서의 신호에 의해 발생하고 소프트 웨어 인터럽트는 명령어의 수행에 의해
		  발생한다
		(1) 외부 인터럽트
			- 전원 이상 인터럽트(Power Fail Interrupt)
				: 정전이 되거나 전원 이상이 있는 경우
			- 기계 착오 인터럽트(Machine Check Interrupt)
				: CPU의 기능적인 오류 동작이 발생한 경우
			- 외부 신호 인터럽트(External Interrupt)
				- 타이머에 의해 규정된 시간(Time Slice)을 알리는 경우
				- 키보드로 인터럽트 키를 누른 경우
				- 외부장치로부터 인터럽트 요청이 있는 경우
		(2) 내부 인터럽트
			- 잘못된 명령이나 데이터를 사용할 때 발생하며, 트랩(Trap)이라고도 부른다
			<프로그램 검사 인터럽트(Program Check Interrupt)>
				- 0으로 나누기(Divide by zero)가 발생한 경우
				- Overflow 또는 Underflow가 발생한 경우
				- 프로그램에서 명령어를 잘못 사용한 경우
				- 부당한 기억장소의 참조와 같은 프로그램의 오류
		(3) 소프트웨어 인터럽트
			- 프로그램 처리 중 명령의 요청에 의해 발생하는 것으로, 가장 대표적인 형태는 감시
			  프로그램을 호출하는 SVC(SuperVisor Call) 인터럽트가 있다
			<SVC(SuperVisor Call) 인터럽트>
				- 사용자가 SVC 명령어를 써서 의도적으로 호출한 경우
				- 복잡한 입,출력 처리를 해야 하는 경우
				- 기억장치 할당 및 오퍼레이터와 대화를 해야 하는 경우

	- 095. 인터럽트 발생 시 CPU가 확인할 사항
		- 프로그램 카운터 내용
		- 사용한 모든 레지스터의 내용
		- 상태조건의 내용(PSW)

	- 096. 인터럽트의 동작 순서
		- 인터럽트 요청 신호 발생
		- 프로그램 실행을 중단함 : 현재 실행중이던 명령어(Micro Instruction)는 끝까지 실행함
		- 현재의 프로그램 상태를 보존함 : 프로그램 상태는 다음에 실행할 명령의 번지로서 PC가 가짐
		- 인터럽트 처리 루틴을 실행함 : 인터럽트를 요청한 장치를 식별함
		- 인터럽트 서비스(취급) 루틴을 실행함 : 실질적인 인터럽트를 처리함
		- 상태 복구 : 인터럽트 요청 신호가 발생했을 때 보관한 PC의 값을 다시 PC에 저장함
		- 중단된 프로그램 실행 재개 : PC의 값을 이용하여 인터럽트 발생 이전에 수행중이던 프로그램을
					      계속 실행함
		(1) 프로그램 상태 보존
			- 프로그램의 상태 보존이 필요한 이유는 인터럽트 서비스를 완료하고 원래 수행 중이던
			  프로그램으로 복귀하기 위해서입니다
		(2) 인터럽트 발생 시 PC의 값 보관 방법
			- 인터럽트 발생 시 상태를 보존하기 위한 PC의 값은 메모리의 0번지, 스택, 인터럽트 백터
			  중의 한 곳에 저장합니다
		(3) 인터럽트 반응 시간(Interrupt Response Time)
			- 인터럽트 요청 신호를 발생한 후부터 인터럽트 취급 루틴의 수행이 시작될 때까지의 시간
		(4) 인터럽트 벡터
			- 중앙처리장치는 인터럽트가 발생한 장치번호를 받은 후에는 해당되는 인터럽트 서비스(취급)
			  루틴으로 분기하게 됩니다
			- 이때 기억장치 내의 특정한 곳에는 인터럽트 취급 루틴으로 분기하는 명령어들만을 기억하는
			  영역이 있는데, 이를 인터럽트 벡터라고 합니다
			- 인터럽트 벡터에는 인터럽트가 발생했을 때 프로세서의 인터럽트 서비스가 특정한 장소로
			  점프하도록 점프할 분기번지가 기억되어 있습니다

	- 097. 인터럽트 우선순위
		- 목적 : 여러 장치에서 동시에 인터럽트가 발생하였을 때 먼저 서비스할 장치를 결정하기 위해서임
		(1) 기능 
			- 각 장치에 우선순위를 부과하는 기능
			- 인터럽트를 요청한 장치의 우선순위를 판별하는 기능
			- 우선순위가 높은 것을 먼저 처리할 수 있는 기능
		(2) 우선순위(높음 > 낮음)
			: 전원 이상(Power Fail) > 기계 착오(Machine Check) > 외부 신호(External Signal) 
			  > 입출력(I/0) > 명령어 잘못 > 프로그램 검사(Program Check) > SVC(SuperVisor Call)
		<마스크 불가 인터럽트(NMI:Non - Maskable Interrupt)>
			: 심각한 기억장치 오류나 정전 사태와 같은 급박한 상황에서 발생하는 것으로, 다른 어떤
			  서비스 요구에도 방해를 받지 않고 CPU에 전달됩니다

	- 098. 인터럽트 우선순위 판별 방법
		(1) 소프트웨어적인 방법 : Polling
			- Interrupt 발생 시 가장 높은 우선순위의 인터럽트 자원(Source)부터 차례로 검사해서,
			  우선순위가 가장 높은 Interrupt 자원(Source)를 찾아내어 이에 해당하는 인터럽트 서비스
			  루틴을 수행하는 방식이다
			- 소프트웨어적인 방식을 폴링이라고 한다
			- 우선순위 변경이 쉬우며, 자기디스크와 같이 속도가 빠른 장치에 높은 등급을 부여한다
			- 많은 인터럽트가 있을 경우 그들을 모두 조사하는 데 많은 시간이 걸려 반응 시간이
			  느리다는 단점이 있다
			- 회로가 간단하고 융통성이 있으며, 별도의 하드웨어가 필요 없으므로 경제적이다
		(2) 하드웨어 적인 방법 : Vectored Interrupt
			- CPU와 Interrupt를 요청할 수 있는 장치 사이에 장치번호에 해당하는 버스를 병렬이나
			  직렬로 연결하여 요청장치의 번호를 CPU에 알리는 방식이다
			- 벡터 인터럽트 방식에서는 인터럽트를 발생한 장치가 프로세서에게 분기할 곳에 대한
			  정보를 제공하는데, 이 정보를 인터럽트 벡터라 한다
			- 벡터 인터럽트를 하드웨어 신호에 의해서 수행되는 서브 루틴이라고도 한다
			- 장치 판별을 위한 별도의 프로그램 루틴이 없어 응답 속도가 빠르다
			- 회로가 복잡하고 융통성이 없으며 추가적인 하드웨어가 필요하므로 비경제적이다
			< 직렬(Serial) 우선순위 부여 방식 >
				- 데이지 체인(Daisy-Chain) 방식이다
				- 인터럽트가 발생하는 모든 장치를 한 개의 회선에 직렬로 연결한다
				- 우선순위가 높은 장치를 선두에 위치시키고 나머지를 우선순위에 따라 차례로
				  연결한다
			< 병렬(Parallel) 우선순위 부여 방식 >
				- 인터럽트가 발생하는 각 장치를 개별적인 회선으로 연결한다
				- 각 장치의 인터럽트 요청을 제어하기 위해 각 비트를 개별적으로 Set할 수 있는
				  Mask Register를 사용한다
				- 우선순위는 Mask Register의 비트 위치에 의해서 결정된다
				- 마스크 레지스터는 우선순위가 높은 것이 서비스 받고 있을 때 우선순위가 낮은
				  것을 비활성화 시킬 수 있다
				- 우선순위가 높은 Interrupt는 낮은 Interrupt가 처리되는 중에도 우선 처리된다
